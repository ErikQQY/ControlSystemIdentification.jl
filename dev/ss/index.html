<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State-space estimation · ControlSystemIdentification Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ControlSystemIdentification Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iddata/">Identification data</a></li><li class="is-active"><a class="tocitem" href>State-space estimation</a><ul class="internal"><li><a class="tocitem" href="#Subspace-based-identification-using-n4sid-1"><span>Subspace-based identification using n4sid</span></a></li><li><a class="tocitem" href="#ERA-and-OKID-1"><span>ERA and OKID</span></a></li><li><a class="tocitem" href="#PEM-1"><span>PEM</span></a></li><li><a class="tocitem" href="#Filtering-and-simulation-1"><span>Filtering and simulation</span></a></li></ul></li><li><a class="tocitem" href="../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../impulse/">Impulse-response estimation</a></li><li><a class="tocitem" href="../freq/">Frequency-domain estimation</a></li><li><a class="tocitem" href="../validation/">Validation</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/temp/">Temperature control</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>State-space estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State-space estimation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/ss.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LTI-state-space-models-1"><a class="docs-heading-anchor" href="#LTI-state-space-models-1">LTI state-space models</a><a class="docs-heading-anchor-permalink" href="#LTI-state-space-models-1" title="Permalink"></a></h1><p>There exist several methods for identification of statespace models, <a href="#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a>, <a href="#ControlSystemIdentification.n4sid"><code>n4sid</code></a> and <a href="#ControlSystemIdentification.pem"><code>pem</code></a>. <a href="#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> is the most comprehensive algorithm for subspace-based identification whereas <code>n4sid</code> is an older implementation. <a href="#ControlSystemIdentification.pem"><code>pem</code></a> solves the prediction-error problem using an iterative optimization method (from Optim.jl). If unsure which method to use, try <a href="#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> first.</p><h2 id="Subspace-based-identification-using-n4sid-1"><a class="docs-heading-anchor" href="#Subspace-based-identification-using-n4sid-1">Subspace-based identification using n4sid</a><a class="docs-heading-anchor-permalink" href="#Subspace-based-identification-using-n4sid-1" title="Permalink"></a></h2><pre><code class="language-julia">d = iddata(y,u,sampletime)
sys = n4sid(d, :auto; verbose=false)
# or use a robust version of svd if y has outliers or missing values
using TotalLeastSquares
sys = n4sid(d, :auto; verbose=false, svd=x-&gt;rpca(x)[3])</code></pre><p>Estimate a statespace model using the <a href="#ControlSystemIdentification.n4sid"><code>n4sid</code></a> method. Returns an object of type <a href="@ref"><code>N4SIDResult</code></a> where the model is accessed as <code>sys.sys</code>. The frequency-weighting functionality is borrowing ideas from <em>&quot;Frequency Weighted Subspace Based System Identification in the Frequency Domain&quot;, Tomas McKelvey 1996</em>. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).</p><h2 id="ERA-and-OKID-1"><a class="docs-heading-anchor" href="#ERA-and-OKID-1">ERA and OKID</a><a class="docs-heading-anchor-permalink" href="#ERA-and-OKID-1" title="Permalink"></a></h2><p>See <a href="#ControlSystemIdentification.era"><code>era</code></a> and <a href="#ControlSystemIdentification.okid"><code>okid</code></a>.</p><h2 id="PEM-1"><a class="docs-heading-anchor" href="#PEM-1">PEM</a><a class="docs-heading-anchor-permalink" href="#PEM-1" title="Permalink"></a></h2><p>A simple algorithm for identification of discrete-time LTI systems on state-space form:</p><div>\[x&#39; = Ax + Bu + Ke\]</div><div>\[y  = Cx + e\]</div><p>is provided. The user can choose to minimize either prediction errors or simulation errors, with arbitrary metrics, i.e., not limited to squared errors.</p><p>The result of the identification with <a href="#ControlSystemIdentification.pem"><code>pem</code></a> is a custom type <code>StateSpaceNoise &lt;: ControlSystems.LTISystem</code>, with fields <code>A,B,K</code>, representing the dynamics matrix, input matrix and Kalman gain matrix, respectively. The observation matrix <code>C</code> is not stored, as this is always given by <code>[I 0]</code> (you can still access it through <code>sys.C</code> thanks to <code>getproperty</code>).</p><h3 id="Usage-example-1"><a class="docs-heading-anchor" href="#Usage-example-1">Usage example</a><a class="docs-heading-anchor-permalink" href="#Usage-example-1" title="Permalink"></a></h3><p>Below, we generate a system and simulate it forward in time. We then try to estimate a model based on the input and output sequences.</p><pre><code class="language-">using ControlSystemIdentification, ControlSystems, Random, LinearAlgebra
using ControlSystemIdentification: newpem
sys = c2d(tf(1, [1, 0.5, 1]) * tf(1, [1, 1]), 0.1)

Random.seed!(1)
T   = 1000                      # Number of time steps
nx  = 3                         # Number of poles in the true system
x0  = randn(nx)                 # Initial state
sim(sys,u,x0=x0) = lsim(ss(sys), u, x0=x0)[1] # Helper function
u   = randn(nu,T)               # Generate random input
y   = sim(sys, u, x0)           # Simulate system
d   = iddata(y,u,0.1)

sysh,opt = newpem(d, nx, focus=:prediction) # Estimate model

yh = predict(sysh, d)      # Predict using estimated model
predplot(sysh, d)   # Plot prediction and true output</code></pre><p>See the <a href=" https:/github.com/JuliaControl/ControlExamples.jl/blob/master/identification_statespace.ipynb">example notebooks</a> for more plots.</p><h3 id="Internals-1"><a class="docs-heading-anchor" href="#Internals-1">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-1" title="Permalink"></a></h3><p>Internally, <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> is used to optimize the system parameters, using automatic differentiation to calculate gradients (and Hessians where applicable). Optim solver options can be controlled by passing keyword arguments to <code>pem</code>, and by passing a manually constructed solver object. The default solver is <a href="http://julianlsolvers.github.io/Optim.jl/stable/#algo/lbfgs/"><code>BFGS()</code></a></p><h2 id="Filtering-and-simulation-1"><a class="docs-heading-anchor" href="#Filtering-and-simulation-1">Filtering and simulation</a><a class="docs-heading-anchor-permalink" href="#Filtering-and-simulation-1" title="Permalink"></a></h2><p>Models can be simulated using <code>lsim</code> from ControlSystems.jl and using <a href="../api/#ControlSystemIdentification.simulate"><code>simulate</code></a>. You may also convert the model to a <a href="@ref"><code>KalmanFilter</code></a> from <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl">LowLevelParticleFilters.jl</a> by calling <code>KalmanFilter(sys)</code>, after which you can perform filtering and smoothing etc. with the utilities provided for a <code>KalmanFilter</code>.</p><p>Furthermore, we have the utility functions below</p><ul><li><a href="../api/#StatsBase.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}"><code>predict</code></a><code>(sys, d, x0=zeros)</code>: Form predictions using estimated <code>sys</code>, this essentially runs a stationary Kalman filter.</li><li><a href="../api/#ControlSystemIdentification.simulate"><code>simulate</code></a><code>(sys, u, x0=zeros)</code>: Simulate the system using input <code>u</code>. The noise model and Kalman gain does not have any influence on the simulated output.</li><li><a href="@ref"><code>observer_predictor</code></a>: Extract the predictor model from the estimated system (<code>ss(A-KC,[B K],C,D)</code>).</li><li><a href="@ref"><code>observer_controller</code></a></li><li><a href="@ref"><code>prediction_error</code></a></li><li><a href="@ref"><code>predictiondata</code></a></li><li><a href="../api/#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}"><code>noise_model</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid" href="#ControlSystemIdentification.subspaceid"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subspaceid(
    data::InputOutputData,
    nx = :auto;
    verbose = false,
    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used
    s1 = r, # number of past outputs
    s2 = r, # number of past inputs
    W = :MOESP,
    zeroD = false,
    stable = true, 
    focus = :prediction,
    svd::F1 = svd!,
    scaleU = true,
    Aestimator::F2 = \,
    Bestimator::F3 = \,
    weights = nothing,
)</code></pre><p>Estimate a state-space model using subspace-based identification.</p><p>Ref: Ljung, Theory for the user.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Identification data <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>nx</code>: Rank of the model (model order)</li><li><code>verbose</code>: Print stuff?</li><li><code>r</code>: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.</li><li><code>s1</code>: past horizon of outputs</li><li><code>s2</code>: past horizon of inputs</li><li><code>W</code>: Weight type, choose between <code>:MOESP, :CVA, :N4SID, :IVM</code></li><li><code>zeroD</code>: Force the <code>D</code> matrix to be zero.</li><li><code>stable</code>: Stabilize unstable system using eigenvalue reflection.</li><li><code>focus</code>: <code>:prediction</code> or <code>simulation</code></li><li><code>svd</code>: The function to use for <code>svd</code></li><li><code>scaleU</code>: Rescale the input channels to have the same energy.</li><li><code>Aestimator</code>: Estimator function used to estimate <code>A,C</code>.</li><li><code>Bestimator</code>: Estimator function used to estimate <code>B,D</code>.</li><li><code>weights</code>: A vector of weights can be provided if the <code>Bestimator</code> is <code>wls</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace2.jl#L158-L197">source</a></section><section><div><pre><code class="language-julia">subspaceid(frd::FRD, args...; estimate_x0 = false, kwargs...)</code></pre><p>If a frequency-reponse data object is supplied</p><ul><li>The FRD will be automatically converted to an <a href="@ref"><code>InputOutputFreqData</code></a></li><li><code>estimate_x0</code> is by default set to 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace2.jl#L372-L378">source</a></section><section><div><pre><code class="language-julia">subspaceid(data::InputOutputFreqData,
    Ts = data.Ts,
    nx = :auto;
    cont = false,
    verbose = false,
    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order
    zeroD = false,
    estimate_x0 = true,
    stable = true, 
    svd = svd!,
    Aestimator = \,
    Bestimator = \,
    weights = nothing
)</code></pre><p>Estimate a state-space model using subspace-based identification in the frequency domain.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: A frequency-domain identification data object.</li><li><code>Ts</code>: Sample time at which the data was collected</li><li><code>nx</code>: Desired model order, an interer or <code>:auto</code>.</li><li><code>cont</code>: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function <code>d2c</code>.</li><li><code>verbose</code>: Print stuff?</li><li><code>r</code>: Internal model order, must be ≥ <code>nx</code>.</li><li><code>zeroD</code>: Force the <code>D</code> matrix to be zero.</li><li><code>estimate_x0</code>: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.</li><li><code>stable</code>: For the model to be stable (uses <a href="@ref"><code>schur_stab</code></a>).</li><li><code>svd</code>: The <code>svd</code> function to use.</li><li><code>Aestimator</code>: The estimator of the <code>A</code> matrix (and initial <code>C</code>-matrix).</li><li><code>Bestimator</code>: The estimator of B/D and C/D matrices.</li><li><code>weights</code>: An optional vector of frequency weights of the same length as the number of frequencies in `data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace2.jl#L388-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.n4sid" href="#ControlSystemIdentification.n4sid"><code>ControlSystemIdentification.n4sid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">res = n4sid(data, r=:auto; verbose=false)</code></pre><p>Estimate a statespace model using the n4sid method. Returns an object of type <a href="#ControlSystemIdentification.N4SIDStateSpace"><code>N4SIDStateSpace</code></a> where the model is accessed as <code>res.sys</code>.</p><p>Implements the simplified algorithm (alg 2) from &quot;N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems&quot; PETER VAN OVERSCHEE and BART DE MOOR</p><p>The frequency weighting is borrowing ideas from &quot;Frequency Weighted Subspace Based System Identication in the Frequency Domain&quot;, Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Identification data <code>data = iddata(y,u)</code></li><li><code>r</code>: Rank of the model (model order)</li><li><code>verbose</code>: Print stuff?</li><li><code>Wf</code>: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like <code>Wf = Bandstop(lower, upper, fs=1/Ts)</code> to indicate that there are disturbances <em>outside</em> this band.</li><li><code>i</code>: Algorithm parameter, generally no need to tune this</li><li><code>γ</code>: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.</li><li><code>zeroD</code>: defaults to false</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.pem" href="#ControlSystemIdentification.pem"><code>ControlSystemIdentification.pem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sys, x0, opt = pem(data; nx, kwargs...)</code></pre><p>System identification using the prediction-error method.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: iddata object containing <code>y</code> and <code>u</code>.<ul><li><code>y</code>: Measurements, either a matrix with time along dim 2, or a vector of vectors</li><li><code>u</code>: Control signals, same structure as <code>y</code></li></ul></li><li><code>nx</code>: Number of poles in the estimated system. Thus number should be chosen as number of system poles plus number of poles in noise models for measurement noise and load disturbances.</li><li><code>focus</code>: Either <code>:prediction</code> or <code>:simulation</code>. If <code>:simulation</code> is chosen, a two stage problem is solved with prediction focus first, followed by a refinement for simulation focus.</li><li><code>metric</code>: A Function determining how the size of the residuals is measured, default <code>sse</code> (e&#39;e), but any Function such as <code>norm</code>, <code>e-&gt;sum(abs,e)</code> or <code>e -&gt; e&#39;Q*e</code> could be used.</li><li><code>regularizer(p)=0</code>: function for regularization. The structure of <code>p</code> is detailed below</li><li><code>solver</code> Defaults to <code>Optim.BFGS()</code></li><li><code>stabilize_predictor=true</code>: Modifies the estimated Kalman gain <code>K</code> in case <code>A-KC</code> is not stable by moving all unstable eigenvalues to the unit circle.</li><li><code>difficult=false</code>: If the identification problem appears to be difficult and ends up in a local minimum, set this flag to true to solve an initial global optimization problem to supply a good initial guess. This is expected to take some time.</li><li><code>kwargs</code>: additional keyword arguments are sent to <code>Optim.Options</code>.</li></ul><p><strong>Return values</strong></p><ul><li><code>sys::StateSpaceNoise</code>: identified system. Can be converted to <code>StateSpace</code> by <code>convert(StateSpace, sys)</code> or <code>ss(sys)</code>, but this will discard the Kalman gain matrix, see <code>innovation_form</code> to obtain a predictor system.</li><li><code>x0</code>: Estimated initial state</li><li><code>opt</code>: Optimization problem structure. Contains info of the result of the optimization problem</li></ul><p><strong>Structure of parameter vector <code>p</code></strong></p><p>The parameter vector is of type <a href="https://github.com/jonniedie/ComponentArrays.jl"><code>ComponentVector</code></a> and the fields <code>A,B,K,x0</code> can be accessed as <code>p.A</code> etc. The internal storage is according to</p><pre><code class="language-julia">A = size(nx,nx)
B = size(nx,nu)
K = size(nx,ny)
x0 = size(nx)
p = [A[:]; B[:]; K[:]; x0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/pem.jl#L23-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.newpem" href="#ControlSystemIdentification.newpem"><code>ControlSystemIdentification.newpem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newpem(
    d,
    nx;
    zeroD = true,
    sys0 = subspaceid(d, nx; zeroD),
    focus = :prediction,
    optimizer = BFGS(
        alphaguess = LineSearches.InitialStatic(alpha = 1),
        linesearch = LineSearches.HagerZhang(),
    ),
    zerox0 = false,
    initx0 = false,
    store_trace = true,
    show_trace = true,
    show_every = 50,
    iterations = 10000,
    allow_f_increases = false,
    time_limit = 100,
    x_tol = 0,
    f_abstol = 0,
    g_tol = 1e-12,
    f_calls_limit = 0,
    g_calls_limit = 0,
)</code></pre><p>A new implementation of the prediction-error method (PEM). Note that this is an experimental implementation and subject to breaking changes not respecting semver.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>nx</code>: Model order</li><li><code>zeroD</code>: Force zero <code>D</code> matrix</li><li><code>sys0</code>: Initial guess, if non provided, <a href="#ControlSystemIdentification.subspaceid"><code>subspaceid</code></a> is used as initial guess.</li><li><code>focus</code>: <code>prediction</code> or <code>:simulation</code>. If <code>:simulation</code>, hte <code>K</code> matrix will be zero.</li><li><code>optimizer</code>: One of Optim&#39;s optimizers</li><li><code>zerox0</code>: Force initial state to zero.</li><li><code>initx0</code>: Estimate initial state once, otherwise at each iteration</li></ul><p>The rest of the arguments are related to <code>Optim.Options</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/pem.jl#L159-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.era" href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">era(YY::AbstractArray{&lt;:Any, 3}, Ts, r::Int, m::Int, n::Int)</code></pre><p>Eigenvalue realization algorithm.</p><p><strong>Arguments:</strong></p><ul><li><code>YY</code>: Markov parameters (impulse response) size <code>n_out×n_in×n_time</code></li><li><code>Ts</code>: Sample time</li><li><code>r</code>: Model order</li><li><code>m</code>: Number of rows in Hankel matrix</li><li><code>n</code>: Number of columns in Hankel matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace.jl#L309-L320">source</a></section><section><div><pre><code class="language-julia">era(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r; p = l, λ=0)</code></pre><p>Eigenvalue realization algorithm. Uses <code>okid</code> to find the Markov parameters as an initial step.</p><p><strong>Arguments:</strong></p><ul><li><code>r</code>: Model order</li><li><code>l</code>: Number of Markov parameters to estimate.</li><li><code>λ</code>: Regularization parameter</li><li><code>p</code>: Optionally, delete the first <code>p</code> columns in the internal Hankel matrices to account for initial conditions != 0. If <code>x0 != 0</code>, for <code>era</code>, <code>p</code> defaults to <code>l</code>, while when calling <code>okid</code> directly, <code>p</code> defaults to 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace.jl#L359-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.okid" href="#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)</code></pre><p>Observer Kalman filter identification. Returns the Markov parameters <code>H</code> size <code>n_out×n_in×l+1</code></p><p><strong>Arguments:</strong></p><ul><li><code>nx</code>: Model order</li><li><code>l</code>: Number of Markov parameters to estimate.</li><li><code>λ</code>: Regularization parameter</li><li><code>p</code>: Optionally, delete the first <code>p</code> columns in the internal Hankel matrices to account for initial conditions != 0. If <code>x0 != 0</code>, try setting <code>p</code> around the same value as <code>l</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/16cc8a5a926008d04826135c685df7920a9c592f/src/subspace.jl#L374-L384">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../iddata/">« Identification data</a><a class="docs-footer-nextpage" href="../tf/">Transfer-function estimation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 6 February 2022 16:23">Sunday 6 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

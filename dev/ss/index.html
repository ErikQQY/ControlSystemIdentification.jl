<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State-space estimation · ControlSystemIdentification Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ControlSystemIdentification Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iddata/">Identification data</a></li><li class="is-active"><a class="tocitem" href>State-space estimation</a><ul class="internal"><li><a class="tocitem" href="#Subspace-based-identification-using-n4sid-1"><span>Subspace-based identification using n4sid</span></a></li><li><a class="tocitem" href="#ERA-and-OKID-1"><span>ERA and OKID</span></a></li><li><a class="tocitem" href="#PEM-1"><span>PEM</span></a></li><li><a class="tocitem" href="#Filtering-and-simulation-1"><span>Filtering and simulation</span></a></li></ul></li><li><a class="tocitem" href="../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../impulse/">Impulse-response estimation</a></li><li><a class="tocitem" href="../freq/">Frequency-domain estimation</a></li><li><a class="tocitem" href="../validation/">Validation</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/temp/">Temperature control</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>State-space estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State-space estimation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/ss.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LTI-state-space-models-1"><a class="docs-heading-anchor" href="#LTI-state-space-models-1">LTI state-space models</a><a class="docs-heading-anchor-permalink" href="#LTI-state-space-models-1" title="Permalink"></a></h1><p>There exist several methods for identification of statespace models, <a href="../api/#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>subspaceid</code></a>, <a href="../api/#ControlSystemIdentification.n4sid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2}"><code>n4sid</code></a> and <a href="../api/#ControlSystemIdentification.pem-Tuple{Any}"><code>pem</code></a>. <a href="../api/#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>subspaceid</code></a> is the most comprehensive algorithm for subspace-based identification whereas <code>n4sid</code> is an older implementation. <a href="../api/#ControlSystemIdentification.pem-Tuple{Any}"><code>pem</code></a> solves the prediction-error problem using an iterative optimization method (from Optim.jl). If unsure which method to use, try <a href="../api/#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>subspaceid</code></a> first.</p><h2 id="Subspace-based-identification-using-n4sid-1"><a class="docs-heading-anchor" href="#Subspace-based-identification-using-n4sid-1">Subspace-based identification using n4sid</a><a class="docs-heading-anchor-permalink" href="#Subspace-based-identification-using-n4sid-1" title="Permalink"></a></h2><pre><code class="language-julia">d = iddata(y,u,sampletime)
sys = n4sid(d, :auto; verbose=false)
# or use a robust version of svd if y has outliers or missing values
using TotalLeastSquares
sys = n4sid(d, :auto; verbose=false, svd=x-&gt;rpca(x)[3])</code></pre><p>Estimate a statespace model using the <a href="../api/#ControlSystemIdentification.n4sid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2}"><code>n4sid</code></a> method. Returns an object of type <a href="@ref"><code>N4SIDResult</code></a> where the model is accessed as <code>sys.sys</code>. The frequency-weighting functionality is borrowing ideas from <em>&quot;Frequency Weighted Subspace Based System Identification in the Frequency Domain&quot;, Tomas McKelvey 1996</em>. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).</p><h2 id="ERA-and-OKID-1"><a class="docs-heading-anchor" href="#ERA-and-OKID-1">ERA and OKID</a><a class="docs-heading-anchor-permalink" href="#ERA-and-OKID-1" title="Permalink"></a></h2><p>See <a href="../api/#ControlSystemIdentification.era"><code>era</code></a> and <a href="../api/#ControlSystemIdentification.okid"><code>okid</code></a>.</p><h2 id="PEM-1"><a class="docs-heading-anchor" href="#PEM-1">PEM</a><a class="docs-heading-anchor-permalink" href="#PEM-1" title="Permalink"></a></h2><p>A simple algorithm for identification of discrete-time LTI systems on state-space form:</p><div>\[x&#39; = Ax + Bu + Ke\]</div><div>\[y  = Cx + e\]</div><p>is provided. The user can choose to minimize either prediction errors or simulation errors, with arbitrary metrics, i.e., not limited to squared errors.</p><p>The result of the identification with <a href="../api/#ControlSystemIdentification.pem-Tuple{Any}"><code>pem</code></a> is a custom type <code>StateSpaceNoise &lt;: ControlSystems.LTISystem</code>, with fields <code>A,B,K</code>, representing the dynamics matrix, input matrix and Kalman gain matrix, respectively. The observation matrix <code>C</code> is not stored, as this is always given by <code>[I 0]</code> (you can still access it through <code>sys.C</code> thanks to <code>getproperty</code>).</p><h3 id="Usage-example-1"><a class="docs-heading-anchor" href="#Usage-example-1">Usage example</a><a class="docs-heading-anchor-permalink" href="#Usage-example-1" title="Permalink"></a></h3><p>Below, we generate a system and simulate it forward in time. We then try to estimate a model based on the input and output sequences.</p><pre><code class="language-julia">using ControlSystemIdentification, ControlSystems, Random, LinearAlgebra

function ⟂(x)
    u,s,v = svd(x)
    u*v
end
function generate_system(nx,ny,nu)
    U,S  = ⟂(randn(nx,nx)), diagm(0=&gt;0.2 .+ 0.5rand(nx))
    A    = S*U
    B   = randn(nx,nu)
    C   = randn(ny,nx)
    sys = ss(A,B,C,0,1)
end

Random.seed!(1)
T   = 1000                      # Number of time steps
nx  = 3                         # Number of poles in the true system
nu  = 1                         # Number of control inputs
ny  = 1                         # Number of outputs
x0  = randn(nx)                 # Initial state
sim(sys,u,x0=x0) = lsim(sys, u&#39;, 1:T, x0=x0)[1]&#39; # Helper function
sys = generate_system(nx,nu,ny)
u   = randn(nu,T)               # Generate random input
y   = sim(sys, u, x0)           # Simulate system
d   = iddata(y,u,1)

sysh,x0h,opt = pem(d, nx=nx, focus=:prediction) # Estimate model

yh = predict(sysh, d, x0h)      # Predict using estimated model
plot([y; yh]&#39;, lab=[&quot;y&quot; &quot;ŷ&quot;])   # Plot prediction and true output</code></pre><p>We can also simulate the system with colored noise, necessitating estimating also noise models.</p><pre><code class="language-julia">σu = 0.1 # Noise variances
σy = 0.1

sysn = generate_system(nx,nu,ny)             # Noise system
un   = u + sim(sysn, σu*randn(size(u)),0*x0) # Input + load disturbance
y    = sim(sys, un, x0)
yn   = y + sim(sysn, σy*randn(size(u)),0*x0) # Output + measurement noise
dn   = iddata(yn,un,1)</code></pre><p>The system now has <code>3nx</code> poles, <code>nx</code> for the system dynamics, and <code>nx</code> for each noise model, we indicated this to the main estimation function <code>pem</code>:</p><pre><code class="language-julia">sysh,x0h,opt = pem(dn,nx=3nx, focus=:prediction)
yh           = predict(sysh, dn, x0h) # Form prediction
plot([y; yh]&#39;, lab=[&quot;y&quot; &quot;ŷ&quot;])             # Compare true output (without noise) to prediction</code></pre><p>We can have a look at the singular values of a balanced system Gramian:</p><pre><code class="language-julia">s    = ss(sysh)   # Convert to standard state-space type
s2,G = balreal(s) # Form balanced representation (obs. and ctrb. Gramians are the same
diag(G)           # Singular values of Gramians

# 9-element Array{Float64,1}:
#  3.5972307807882844
#  0.19777167699663994
#  0.0622528285731599
#  0.004322765397504325
#  0.004270259700592557
#  0.003243449461350837
#  0.003150873301312319
#  0.0005827927965893053
#  0.00029732262107216666</code></pre><p>Note that there are 3 big singular values, corresponding to the system poles, there are also 2×3 smaller singular values, corresponding to the noise dynamics.</p><p>The estimated noise model can be extracted by <code>noise_model(sys)</code>, we can visualize it with a bodeplot.</p><pre><code class="language-julia">bodeplot(noise_model(sysh), exp10.(range(-3, stop=0, length=200)), title=&quot;Estimated noise dynamics&quot;)</code></pre><p>See the <a href=" https:/github.com/JuliaControl/ControlExamples.jl?files=1">example notebooks</a> for these plots.</p><h3 id="Internals-1"><a class="docs-heading-anchor" href="#Internals-1">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-1" title="Permalink"></a></h3><p>Internally, <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> is used to optimize the system parameters, using automatic differentiation to calculate gradients (and Hessians where applicable). Optim solver options can be controlled by passing keyword arguments to <code>pem</code>, and by passing a manually constructed solver object. The default solver is <a href="http://julianlsolvers.github.io/Optim.jl/stable/#algo/lbfgs/"><code>BFGS()</code></a></p><h2 id="Filtering-and-simulation-1"><a class="docs-heading-anchor" href="#Filtering-and-simulation-1">Filtering and simulation</a><a class="docs-heading-anchor-permalink" href="#Filtering-and-simulation-1" title="Permalink"></a></h2><p>Models can be simulated using <code>lsim</code> from ControlSystems.jl and using <a href="../api/#ControlSystemIdentification.simulate"><code>simulate</code></a>. You may also convert the model to a <a href="@ref"><code>KalmanFilter</code></a> from <a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl">LowLevelParticleFilters.jl</a> by calling <code>KalmanFilter(sys)</code>, after which you can perform filtering and smoothing etc. with the utilities provided for a <code>KalmanFilter</code>.</p><p>Furthermore, we have the utility functions below</p><ul><li><a href="../api/#StatsBase.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}"><code>predict</code></a><code>(sys, d, x0=zeros)</code>: Form predictions using estimated <code>sys</code>, this essentially runs a stationary Kalman filter.</li><li><a href="../api/#ControlSystemIdentification.simulate"><code>simulate</code></a><code>(sys, u, x0=zeros)</code>: Simulate the system using input <code>u</code>. The noise model and Kalman gain does not have any influence on the simulated output.</li><li><a href="@ref"><code>observer_predictor</code></a>: Extract the predictor model from the estimated system (<code>ss(A-KC,[B K],C,D)</code>).</li><li><a href="@ref"><code>observer_controller</code></a></li><li><a href="@ref"><code>prediction_error</code></a></li><li><a href="@ref"><code>predictiondata</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../iddata/">« Identification data</a><a class="docs-footer-nextpage" href="../tf/">Transfer-function estimation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 10 November 2021 08:05">Wednesday 10 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"tf/#Transfer-function-estimation-1","page":"Transfer-function estimation","title":"Transfer function estimation","text":"","category":"section"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Basic support for ARX/ARMAX model estimation, i.e. a model on any of the forms","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Ay = Bu + w","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Ay = Bu + Cw","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Ay = Bu + 1D w","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"is provided. The ARX estimation problem is convex and the solution is available on closed-form. Usage example:","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"N  = 2000     # Number of time steps\nt  = 1:N\nΔt = 1        # Sample time\nu  = randn(N) # A random control input\nG  = tf(0.8, [1,-0.9], 1)\ny  = lsim(G,u,t)[1][:]\nyn = y\nd  = iddata(y,u,Δt)\n\nna,nb = 1,1   # Number of polynomial coefficients\n\nGls = arx(d,na,nb,stochastic=false) # set stochastic to true to get a transfer function of MonteCarloMeasurements.Particles\n@show Gls\n# TransferFunction{ControlSystems.SisoRational{Float64}}\n#     0.8000000000000005\n# --------------------------\n# 1.0*z - 0.8999999999999997","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"As we can see, the model is perfectly recovered. In reality, the measurement signal is often affected by noise, in which case the estimation will suffer. To combat this, a few different options exist:","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"e  = randn(N)\nyn = y + e    # Measurement signal with noise\nd  = iddata(yn,u,Δt)\n\nna,nb,nc = 1,1,1\n\nGls      = arx(d,na,nb, stochastic=true)     # Regular least-squares estimation\nGtls     = arx(d,na,nb, estimator=tls)       # Total least-squares estimation\nGwtls    = arx(d,na,nb, estimator=wtls_estimator(y,na,nb)) # Weighted Total least-squares estimation\nGplr, Gn = plr(d,na,nb,nc, initial_order=20) # Pseudo-linear regression\n@show Gls; @show  Gtls; @show  Gwtls; @show  Gplr; @show  Gn;\n# TransferFunction{ControlSystems.SisoRational{MonteCarloMeasurements.Particles{Float64,500}}}\n#     0.824 ± 0.029\n# ---------------------\n# 1.0*z - 0.713 ± 0.013\n\n# Gtls = TransferFunction{ControlSystems.SisoRational{Float64}}\n#     1.848908051191616\n# -------------------------\n# 1.0*z - 0.774385918070221\n\n# Gwtls = TransferFunction{ControlSystems.SisoRational{Float64}}\n#    0.8180228878106678\n# -------------------------\n# 1.0*z - 0.891939152690534\n\n# Gplr = TransferFunction{ControlSystems.SisoRational{Float64}}\n#     0.8221837077656046\n# --------------------------\n# 1.0*z - 0.8896345125395438\n\n# Gn = TransferFunction{ControlSystems.SisoRational{Float64}}\n#     0.9347035105826179\n# --------------------------\n# 1.0*z - 0.8896345125395438","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"We now see that the estimate using standard least-squares is heavily biased and it is wrongly certain about the estimate (notice the ± in the transfer function coefficients). Regular Total least-squares does not work well in this example, since not all variables in the regressor contain equally much noise. Weighted total least-squares does a reasonable job at recovering the true model. Pseudo-linear regression also fares okay, while simultaneously estimating a noise model. The helper function wtls_estimator(y,na,nb) returns a function that performs wtls using appropriately sized covariance matrices, based on the length of y and the model orders. Weighted total least-squares estimation is provided by TotalLeastSquares.jl. See the example notebooks for more details.","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"Uncertain transfer function with Particles coefficients can be used like any other model. Try, e.g., nyquistplot(Gls) to get a Nyquist plot with confidence bounds.","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"See also function arma for estimation of signal models without inputs.","category":"page"},{"location":"tf/#Functions-1","page":"Transfer-function estimation","title":"Functions","text":"","category":"section"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"arx: Transfer-function estimation using closed-form solution.\nar: Estimate an AR model.\narma: Estimate an ARMA model.\nplr: Transfer-function estimation using pseudo-linear regression\narxar: Transfer-function estimation using generalized least squares method\ngetARXregressor/getARregressor: For low-level control over the estimation","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"See docstrings for further help.","category":"page"},{"location":"tf/#","page":"Transfer-function estimation","title":"Transfer-function estimation","text":"ControlSystemIdentification.arx\nControlSystemIdentification.ar\nControlSystemIdentification.arma\nControlSystemIdentification.plr\nControlSystemIdentification.arxar\nControlSystemIdentification.getARXregressor\nControlSystemIdentification.getARregressor","category":"page"},{"location":"tf/#ControlSystemIdentification.arx","page":"Transfer-function estimation","title":"ControlSystemIdentification.arx","text":"Gtf = arx(d::AbstractIdData, na, nb; inputdelay = ones(Int, size(nb)), λ = 0, estimator=\\, stochastic=false)\n\nFit a transfer Function to data using an ARX model and equation error minimization.\n\nnb and na are the number of coefficients of the numerator and denominator polynomials.\n\nInput delay can be added via inputdelay = d, which corresponds to an additional delay of z^-d. An inputdelay = 0 results in a direct term. The highest order of the B polynomial is given by nb + inputdelay - 1.  λ > 0 can be provided for L₂ regularization. estimator defaults to \\ (least squares), alternatives are estimator = tls for total least-squares estimation.  arx(Δt,yn,u,na,nb, estimator=wtls_estimator(y,na,nb) is potentially more robust in the presence of heavy measurement noise. The number of free parameters is na+nb \n\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nSupports MISO estimation by supplying an iddata with a matrix u, with nb = [nb₁, nb₂...] and optional inputdelay = [d₁, d₂...]\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.ar","page":"Transfer-function estimation","title":"ControlSystemIdentification.ar","text":"ar(d::AbstractIdData, na; λ=0, estimator=\\, scaleB=false, stochastic=false)\n\nEstimate an AR transfer function G = 1/A, the AR process is defined as A(z⁻¹)y(t) = e(t)\n\nArguments:\n\nd: IdData, see iddata\nna: order of the model\nλ: λ > 0 can be provided for L₂ regularization\nestimator: e.g. \\,tls,irls,rtls\nscaleB: Whether or not to scale the numerator using the variance of the prediction error.\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nEstimation of AR models using least-squares is known to struggle with heavy measurement noise, using estimator = tls can improve the result in this case.\n\nExample\n\njulia> N = 10000\n10000\n\njulia> e = [-0.2; zeros(N-1)] # noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> G = tf([1, 0], [1, -0.9], 1) # AR transfer function\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z - 0.9\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> y = lsim(G, e, 1:N)[1][:] # Get output of AR transfer function from input noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> Gest = ar(iddata(y), 1) # Estimate AR transfer function from output y\nTransferFunction{Discrete{Float64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z - 0.8999999999999998\n\nSample Time: 1.0 (seconds)\nDiscrete-time transfer function model\n\njulia> G ≈ Gest # Test if estimation was correct\ntrue\n\njulia> eest = lsim(1/Gest, y, 1:N)[1][:] # recover the input noise e from output y and estimated transfer function Gest\n10000-element Vector{Float64}:\n[...]\n\njulia> isapprox(eest, e, atol = eps()) # input noise correct recovered\ntrue \n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.arma","page":"Transfer-function estimation","title":"ControlSystemIdentification.arma","text":"model = arma(d::AbstractIdData, na, nc; initial_order=20, method=:ls)\n\nEstimate a Autoregressive Moving Average model with na coefficients in the denominator and nc coefficients in the numerator. Returns the model and the estimated noise sequence driving the system.\n\nArguments:\n\nd: iddata\ninitial_order: An initial AR model of this order is used to estimate the residuals\nestimator: A function (A,y)->minimizeₓ(Ax-y) default is \\ but another option is wtls_estimator(1:length(y)-initial_order,na,nc,ones(nc))\n\nSee also estimate_residuals\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.plr","page":"Transfer-function estimation","title":"ControlSystemIdentification.plr","text":"G, Gn = plr(d::AbstractIdData,na,nb,nc; initial_order = 20)\n\nPerform pseudo-linear regression to estimate a model on the form Ay = Bu + Cw The residual sequence is estimated by first estimating a high-order arx model, whereafter the estimated residual sequence is included in a second estimation problem. The return values are the estimated system model, and the estimated noise model. G and Gn will always have the same denominator polynomial.\n\narmax is an alias for plr. See also pem, ar, arx\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.arxar","page":"Transfer-function estimation","title":"ControlSystemIdentification.arxar","text":"G, H, e = arxar(d::InputOutputData, na::Int, nb::Union{Int, Vector{Int}}, nd::Int)\n\nEstimate the ARXAR model Ay = Bu + v, where v = He and H = 1/D, using generalized least-squares method. For more information see Söderström - Convergence properties of the generalized least squares identification method, 1974. \n\nArguments:\n\nd: iddata\nna: order of A\nnb: number of coefficients in B, the order is determined by nb + inputdelay - 1. In MISO estimation it takes the form nb = [nb₁, nb₂...]. \nnd: order of D\n\nKeyword Arguments:\n\nH = nothing: prior knowledge about the AR noise model\ninputdelay = ones(Int, size(nb)): optional delay of input, inputdelay = 0 results in a direct term, takes the form inputdelay = [d₁, d₂...] in MISO estimation \nλ = 0: λ > 0 can be provided for L₂ regularization\nestimator = \\: e.g. \\,tls,irls,rtls, the latter three require using TotalLeastSquares\nδmin = 10e-4: Minimal change in the power of e, that specifies convergence.\niterations = 10: maximum number of iterations.\nverbose = false: if true, more information is printed\n\nExample:\n\njulia> N = 500 \n500\n\njulia> sim(G, u) = lsim(G, u, 1:N)[1][:]\nsim (generic function with 1 method)\n\njulia> A = tf([1, -0.8], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z - 0.8\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> B = tf([0, 1], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}\n1\n-\nz\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> G = minreal(B / A)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0\n----------\n1.0z - 0.8\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> D = tf([1, 0.7], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z + 0.7\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> H = 1 / D\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z + 0.7\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> u, e = randn(1, N), randn(1, N)\n[...]\n\njulia> y, v = sim(G, u), sim(H * (1/A), e) # simulate process\n[...]\n\njulia> d = iddata(y .+ v, u, 1)\nInputOutput data of length 500 with 1 outputs and 1 inputs\n\njulia> na, nb , nd = 1, 1, 1\n(1, 1, 1)\n\njulia> Gest, Hest, res = arxar(d, na, nb, nd)\n(G = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   0.9987917259291642\n-------------------------\n1.0z - 0.7937837464682017\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, H = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z + 0.7019519225937721\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, e = [...]\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.getARXregressor","page":"Transfer-function estimation","title":"ControlSystemIdentification.getARXregressor","text":"getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb; inputdelay = ones(Int, size(nb)))\n\nReturns a shortened output signal y and a regressor matrix A such that the least-squares ARX model estimate of order na,nb is y\\A Return a regressor matrix used to fit an ARX model on, e.g., the form A(z)y = B(z)f(u) with output y and input u where the order of autoregression is na, the order of input moving average is nb and an optional input delay inputdelay. Caution, changing the input delay changes the order to nb + inputdelay - 1. An inputdelay = 0 results in a direct term. \n\nExample\n\nHere we test the model with the Function f(u) = √(|u|)\n\nA     = [1,2*0.7*1,1] # A(z) coeffs\nB     = [10,5] # B(z) coeffs\nu     = randn(100) # Simulate 100 time steps with Gaussian input\ny     = filt(B,A,u)\nyr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2\nx     = A\\yr # Estimate model polynomials\nplot([yr A*x], lab=[\"Signal\" \"Prediction\"])\n\nFor nonlinear ARX-models, see BasisFunctionExpansions.jl. See also arx\n\n\n\n\n\n","category":"function"},{"location":"tf/#ControlSystemIdentification.getARregressor","page":"Transfer-function estimation","title":"ControlSystemIdentification.getARregressor","text":"yt,A = getARregressor(y::AbstractVector, na)\n\nReturns values such that x = A\\yt. See getARXregressor for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/#Exported-functions-and-types-1","page":"API","title":"Exported functions and types","text":"","category":"section"},{"location":"api/#Index-1","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ControlSystemIdentification]\nPrivate = false","category":"page"},{"location":"api/#ControlSystemIdentification.FRD","page":"API","title":"ControlSystemIdentification.FRD","text":"FRD(w,r)\n\nRepresents frequency-response data. w holds the frequency vector and r the response. Methods defined on this type include\n\n+-*\nlength, vec, sqrt\nplot\nfeedback\nfreqvec\ntfest to estimate a rational model\nIndexing in the frequency domain using, e.g., G[1Hz : 5Hz], G[1rad : 5rad]\n\nIf r represents a MIMO frequency response, the dimensions are ny × nu × nω. freqresp returns a PermutedDimsArray whose .parent field follows this convention.\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.Hz","page":"API","title":"ControlSystemIdentification.Hz","text":"Represents frequencies in Herz for indexing of FRD objects: frd[2Hz:10Hz]\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.N4SIDStateSpace","page":"API","title":"ControlSystemIdentification.N4SIDStateSpace","text":"N4SIDStateSpace <: AbstractPredictionStateSpace\n\nThe result of statespace model estimation using the n4sid method.\n\nFields:\n\nsys: estimated model in the form of a StateSpace object\nQ: estimated covariance matrix of the states\nR: estimated covariance matrix of the measurements\nS: estimated cross covariance matrix between states and measurements\nK: kalman observer gain\nP: solution to the Riccatti equation\nx: estimated state trajectory\ns: singular values\nfve: Fraction of variance explained by singular values\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.rad","page":"API","title":"ControlSystemIdentification.rad","text":"Represents frequencies in rad/s for indexing of FRD objects: frd[2rad:10rad]\n\n\n\n\n\n","category":"type"},{"location":"api/#ControlSystemIdentification.apply_fun","page":"API","title":"ControlSystemIdentification.apply_fun","text":"apply_fun(fun, d::InputOutputData)\n\nApply fun(y) to all time series y[,u,[x]] ∈ d and return a new iddata with the transformed series.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}","page":"API","title":"ControlSystemIdentification.ar","text":"ar(d::AbstractIdData, na; λ=0, estimator=\\, scaleB=false, stochastic=false)\n\nEstimate an AR transfer function G = 1/A, the AR process is defined as A(z⁻¹)y(t) = e(t)\n\nArguments:\n\nd: IdData, see iddata\nna: order of the model\nλ: λ > 0 can be provided for L₂ regularization\nestimator: e.g. \\,tls,irls,rtls\nscaleB: Whether or not to scale the numerator using the variance of the prediction error.\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nEstimation of AR models using least-squares is known to struggle with heavy measurement noise, using estimator = tls can improve the result in this case.\n\nExample\n\njulia> N = 10000\n10000\n\njulia> e = [-0.2; zeros(N-1)] # noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> G = tf([1, 0], [1, -0.9], 1) # AR transfer function\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z - 0.9\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> y = lsim(G, e, 1:N)[1][:] # Get output of AR transfer function from input noise e\n10000-element Vector{Float64}:\n[...]\n\njulia> Gest = ar(iddata(y), 1) # Estimate AR transfer function from output y\nTransferFunction{Discrete{Float64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z - 0.8999999999999998\n\nSample Time: 1.0 (seconds)\nDiscrete-time transfer function model\n\njulia> G ≈ Gest # Test if estimation was correct\ntrue\n\njulia> eest = lsim(1/Gest, y, 1:N)[1][:] # recover the input noise e from output y and estimated transfer function Gest\n10000-element Vector{Float64}:\n[...]\n\njulia> isapprox(eest, e, atol = eps()) # input noise correct recovered\ntrue \n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}","page":"API","title":"ControlSystemIdentification.arma","text":"model = arma(d::AbstractIdData, na, nc; initial_order=20, method=:ls)\n\nEstimate a Autoregressive Moving Average model with na coefficients in the denominator and nc coefficients in the numerator. Returns the model and the estimated noise sequence driving the system.\n\nArguments:\n\nd: iddata\ninitial_order: An initial AR model of this order is used to estimate the residuals\nestimator: A function (A,y)->minimizeₓ(Ax-y) default is \\ but another option is wtls_estimator(1:length(y)-initial_order,na,nc,ones(nc))\n\nSee also estimate_residuals\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}","page":"API","title":"ControlSystemIdentification.arma_ssa","text":"arma_ssa(d::AbstractIdData, na, nc; L=nothing, estimator=\\, robust=false)\n\nDOCSTRING\n\nArguments:\n\nd: iddata\nna: number of denominator parameters\nnc: number of numerator parameters\nL: length of the lag-embedding used to separate signal and noise. nothing corresponds to automatic selection.\nestimator: The function to solve the least squares problem. Examples \\,tls,irls,rtls.\nrobust: Use robust PCA to be resistant to outliers.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}","page":"API","title":"ControlSystemIdentification.arx","text":"Gtf = arx(d::AbstractIdData, na, nb; inputdelay = ones(Int, size(nb)), λ = 0, estimator=\\, stochastic=false)\n\nFit a transfer Function to data using an ARX model and equation error minimization.\n\nnb and na are the number of coefficients of the numerator and denominator polynomials.\n\nInput delay can be added via inputdelay = d, which corresponds to an additional delay of z^-d. An inputdelay = 0 results in a direct term. The highest order of the B polynomial is given by nb + inputdelay - 1.  λ > 0 can be provided for L₂ regularization. estimator defaults to \\ (least squares), alternatives are estimator = tls for total least-squares estimation.  arx(Δt,yn,u,na,nb, estimator=wtls_estimator(y,na,nb) is potentially more robust in the presence of heavy measurement noise. The number of free parameters is na+nb \n\nstochastic: if true, returns a transfer function with uncertain parameters represented by MonteCarloMeasurements.Particles.\n\nSupports MISO estimation by supplying an iddata with a matrix u, with nb = [nb₁, nb₂...] and optional inputdelay = [d₁, d₂...]\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.arxar-Tuple{ControlSystemIdentification.InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}","page":"API","title":"ControlSystemIdentification.arxar","text":"G, H, e = arxar(d::InputOutputData, na::Int, nb::Union{Int, Vector{Int}}, nd::Int)\n\nEstimate the ARXAR model Ay = Bu + v, where v = He and H = 1/D, using generalized least-squares method. For more information see Söderström - Convergence properties of the generalized least squares identification method, 1974. \n\nArguments:\n\nd: iddata\nna: order of A\nnb: number of coefficients in B, the order is determined by nb + inputdelay - 1. In MISO estimation it takes the form nb = [nb₁, nb₂...]. \nnd: order of D\n\nKeyword Arguments:\n\nH = nothing: prior knowledge about the AR noise model\ninputdelay = ones(Int, size(nb)): optional delay of input, inputdelay = 0 results in a direct term, takes the form inputdelay = [d₁, d₂...] in MISO estimation \nλ = 0: λ > 0 can be provided for L₂ regularization\nestimator = \\: e.g. \\,tls,irls,rtls, the latter three require using TotalLeastSquares\nδmin = 10e-4: Minimal change in the power of e, that specifies convergence.\niterations = 10: maximum number of iterations.\nverbose = false: if true, more information is printed\n\nExample:\n\njulia> N = 500 \n500\n\njulia> sim(G, u) = lsim(G, u, 1:N)[1][:]\nsim (generic function with 1 method)\n\njulia> A = tf([1, -0.8], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z - 0.8\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> B = tf([0, 1], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}\n1\n-\nz\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> G = minreal(B / A)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0\n----------\n1.0z - 0.8\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> D = tf([1, 0.7], [1, 0], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n1.0z + 0.7\n----------\n   1.0z\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> H = 1 / D\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   1.0z\n----------\n1.0z + 0.7\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> u, e = randn(1, N), randn(1, N)\n[...]\n\njulia> y, v = sim(G, u), sim(H * (1/A), e) # simulate process\n[...]\n\njulia> d = iddata(y .+ v, u, 1)\nInputOutput data of length 500 with 1 outputs and 1 inputs\n\njulia> na, nb , nd = 1, 1, 1\n(1, 1, 1)\n\njulia> Gest, Hest, res = arxar(d, na, nb, nd)\n(G = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n   0.9987917259291642\n-------------------------\n1.0z - 0.7937837464682017\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, H = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}\n          1.0z\n-------------------------\n1.0z + 0.7019519225937721\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model, e = [...]\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.coherence-Tuple{Any}","page":"API","title":"ControlSystemIdentification.coherence","text":"κ = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming)\n\nCalculates the magnitude-squared coherence Function. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ << 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy. κ: Coherence function (not squared) N: Noise model\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.coherenceplot","page":"API","title":"ControlSystemIdentification.coherenceplot","text":"coherenceplot(d, [(;n=..., noverlap=...); hz=false)\n\nCalculates and plots the (squared) coherence Function κ. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ << 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy.\n\nhz indicates Hertz instead of rad/s\n\nKeyword arguments to coherence are supplied as a named tuple as a second positional argument .\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.crosscorplot","page":"API","title":"ControlSystemIdentification.crosscorplot","text":"crosscorplot(data, [lags])\n\nPlot the cross correlation betweein input and output for lags that default to 10% of the length of the dataset on the negative side and 50% on the positive side but no more than 100 on each side.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.era","page":"API","title":"ControlSystemIdentification.era","text":"era(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r; p = l, λ=0)\n\nEigenvalue realization algorithm. Uses okid to find the Markov parameters as an initial step.\n\nArguments:\n\nr: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, for era, p defaults to l, while when calling okid directly, p defaults to 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.era-Tuple{AbstractArray{var\"#s246\", 3} where var\"#s246\", Any, Int64, Int64, Int64}","page":"API","title":"ControlSystemIdentification.era","text":"era(YY::AbstractArray{<:Any, 3}, Ts, r::Int, m::Int, n::Int)\n\nEigenvalue realization algorithm.\n\nArguments:\n\nYY: Markov parameters (impulse response) size n_out×n_in×n_time\nTs: Sample time\nr: Model order\nm: Number of rows in Hankel matrix\nn: Number of columns in Hankel matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}","page":"API","title":"ControlSystemIdentification.estimate_residuals","text":"estimate_residuals(model, y)\n\nEstimate the residuals driving the dynamics of an ARMA model.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.estimate_x0","page":"API","title":"ControlSystemIdentification.estimate_x0","text":"estimate_x0(sys, d, n = min(length(d), 3 * slowest_time_constant(sys)))\n\nEstimate the initial state of the system \n\nArguments:\n\nd: iddata\nn: Number of samples to use.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{var\"#s252\"} where var\"#s252\"<:Discrete, AbstractMatrix{T} where T}","page":"API","title":"ControlSystemIdentification.filter_bank","text":"filter_bank(basis::AbstractStateSpace{<:Discrete}, signal::AbstractMatrix)\n\nFilter signal through all systems in basis\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.find_na","page":"API","title":"ControlSystemIdentification.find_na","text":"find_na(y::AbstractVector,n::Int)\n\nPlots the RMSE and AIC For model orders up to n. Useful for model selection\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.find_nanb","page":"API","title":"ControlSystemIdentification.find_nanb","text":"find_nanb(d::InputOutputData,na,nb)\n\nPlots the RMSE and AIC For model orders up to n. Useful for model selection\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.find_similarity_transform","page":"API","title":"ControlSystemIdentification.find_similarity_transform","text":"find_similarity_transform(sys1, sys2)\n\nFind T such that ControlSystems.similarity_transform(sys1, T) == sys2\n\nRef: Minimal state-space realization in linear system theory: an overview, B. De Schutter\n\njulia> T = randn(3,3);\n\njulia> sys1 = ssrand(1,1,3);\n\njulia> sys2 = ControlSystems.similarity_transform(sys1, T);\n\n\njulia> T2 = find_similarity_transform(sys1, sys2);\n\njulia> T2 ≈ T\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Any, Any}","page":"API","title":"ControlSystemIdentification.getARXregressor","text":"getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb; inputdelay = ones(Int, size(nb)))\n\nReturns a shortened output signal y and a regressor matrix A such that the least-squares ARX model estimate of order na,nb is y\\A Return a regressor matrix used to fit an ARX model on, e.g., the form A(z)y = B(z)f(u) with output y and input u where the order of autoregression is na, the order of input moving average is nb and an optional input delay inputdelay. Caution, changing the input delay changes the order to nb + inputdelay - 1. An inputdelay = 0 results in a direct term. \n\nExample\n\nHere we test the model with the Function f(u) = √(|u|)\n\nA     = [1,2*0.7*1,1] # A(z) coeffs\nB     = [10,5] # B(z) coeffs\nu     = randn(100) # Simulate 100 time steps with Gaussian input\ny     = filt(B,A,u)\nyr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2\nx     = A\\yr # Estimate model polynomials\nplot([yr A*x], lab=[\"Signal\" \"Prediction\"])\n\nFor nonlinear ARX-models, see BasisFunctionExpansions.jl. See also arx\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.getARregressor-Tuple{AbstractVector{T} where T, Any}","page":"API","title":"ControlSystemIdentification.getARregressor","text":"yt,A = getARregressor(y::AbstractVector, na)\n\nReturns values such that x = A\\yt. See getARXregressor for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.iddata","page":"API","title":"ControlSystemIdentification.iddata","text":"iddata(y,       Ts = nothing)\niddata(y, u,    Ts = nothing)\niddata(y, u, x, Ts = nothing)\n\nReturns the appropriate identification-data object, depending on the input.\n\nArguments\n\ny::AbstractArray: output data (required)\nu::AbstractArray: input data (if available)\nx::AbstractArray: state data (if available)\nTs::Union{Real,Nothing} = nothing: optional sample time\n\nIf the time-series are multivariate, time is in the last dimension.\n\nOperations on iddata\n\nprefilter\nresample\nappend two along the time dimension [d1 d2]\nindex time series d[output_index, input_index]\nindex the time axis with indices d[time_indices]\nindex the time axis with seconds d[3Sec:12Sec] (using ControlSystemIdentification: Sec)\naccess number of inputs, outputs and sample time: d.nu, d.ny, d.Ts\naccess the time time vector d.t\npremultiply to scale outputs C * d\npostmultiply to scale inputs d * B\nwritedlm\nramp_in, ramp_out\nplot\nspecplot\n\nExamples\n\njulia> iddata(randn(10))\nOutput data of length 10 with 1 outputs\n\njulia> iddata(randn(10), randn(10), 1)\nInputOutput data of length 10 with 1 outputs and 1 inputs\n\njulia> d = iddata(randn(2, 10), randn(3, 10), 0.1)\nInputOutput data of length 10 with 2 outputs and 3 inputs\n\njulia> [d d] # Concatenate along time\nInputOutput data of length 20 with 2 outputs and 3 inputs\n\njulia> d[1:3]\nInputOutput data of length 3 with 2 outputs and 3 inputs\n\njulia> d.nu\n3\n\njulia> d.t # access time vector\n0.0:0.1:0.9\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector{T} where T}","page":"API","title":"ControlSystemIdentification.iddata","text":"iddata(y::AbstractArray, u::AbstractArray, w::AbstractVector)\n\nCreate a frequency-domain input-output data object. w is expected to be in rad/s.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}","page":"API","title":"ControlSystemIdentification.impulseest","text":"ir, t, Σ = impulseest(d::AbstractIdData, n; λ=0, estimator=ls)\n\nEstimates the system impulse response by fitting an n:th order FIR model. Returns impulse-response estimate, time vector and covariance matrix. See also impulseestplot\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.impulseestplot","page":"API","title":"ControlSystemIdentification.impulseestplot","text":"impulseestplot(data,n)\n\nEstimates the system impulse response by fitting an n:th order FIR model and plots the result with a 95% confidence band. See also impulseestplot\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.kautz-Tuple{AbstractVector{T} where T, Any}","page":"API","title":"ControlSystemIdentification.kautz","text":"kautz(a::Vector, h)\n\nConstruct a discrete-time Kautz basis of length with poles at a amd sample time h.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.laguerre-Tuple{Any, Any}","page":"API","title":"ControlSystemIdentification.laguerre","text":"laguerre(a::Number, Nq)\n\nConstruct a Laguerre basis of length Nq with poles at a.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}","page":"API","title":"ControlSystemIdentification.laguerre_oo","text":"laguerre_oo(a::Number, Nq)\n\nConstruct an output orthogonalized Laguerre basis of length Nq with poles at a.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous, S} where S<:(ControlSystems.SisoTf{T} where T)}","page":"API","title":"ControlSystemIdentification.minimum_phase","text":"minimum_phase(G)\n\nMove zeros and poles of G from the unstable half plane to the stable. If G is a statespace system, it's converted to a transfer function first. This can incur loss of precision.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any, N} where N}","page":"API","title":"ControlSystemIdentification.model_spectrum","text":"model_spectrum(f, h, args...; kwargs...)\n\nArguments:\n\nf: the model-estimation function, e.g., ar,arma\nh: The sample time\nargs: arguments to f\nkwargs: keyword arguments to f\n\nExample:\n\nusing ControlSystemIdentification, DSP\nT = 1000\ns = sin.((1:T) .* 2pi/10)\nS1 = spectrogram(s,window=hanning)\nestimator = model_spectrum(ar,1,2)\nS2 = spectrogram(s,estimator,window=rect)\nplot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.n4sid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}","page":"API","title":"ControlSystemIdentification.n4sid","text":"res = n4sid(data, r=:auto; verbose=false)\n\nEstimate a statespace model using the n4sid method. Returns an object of type N4SIDStateSpace where the model is accessed as res.sys.\n\nImplements the simplified algorithm (alg 2) from \"N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems\" PETER VAN OVERSCHEE and BART DE MOOR\n\nThe frequency weighting is borrowing ideas from \"Frequency Weighted Subspace Based System Identi\fcation in the Frequency Domain\", Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).\n\nArguments:\n\ndata: Identification data data = iddata(y,u)\nr: Rank of the model (model order)\nverbose: Print stuff?\nWf: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like Wf = Bandstop(lower, upper, fs=1/Ts) to indicate that there are disturbances outside this band.\ni: Algorithm parameter, generally no need to tune this\nγ: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.\nzeroD: defaults to false\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}","page":"API","title":"ControlSystemIdentification.noise_model","text":"noise_model(sys::AbstractPredictionStateSpace)\n\nReturn a model of the noise driving the system, v, in x' = Ax + Bu + Kv y = Cx + Du + v\n\nThe model neglects u and is given by x' = Ax + Kv y = Cx + v\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.okid","page":"API","title":"ControlSystemIdentification.okid","text":"H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)\n\nObserver Kalman filter identification. Returns the Markov parameters H size n_out×n_in×l+1\n\nArguments:\n\nnx: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, try setting p around the same value as l.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.pem-Tuple{Any}","page":"API","title":"ControlSystemIdentification.pem","text":"sys, x0, opt = pem(data; nx, kwargs...)\n\nSystem identification using the prediction-error method.\n\nArguments:\n\ndata: iddata object containing y and u.\ny: Measurements, either a matrix with time along dim 2, or a vector of vectors\nu: Control signals, same structure as y\nnx: Number of poles in the estimated system. Thus number should be chosen as number of system poles plus number of poles in noise models for measurement noise and load disturbances.\nfocus: Either :prediction or :simulation. If :simulation is chosen, a two stage problem is solved with prediction focus first, followed by a refinement for simulation focus.\nmetric: A Function determining how the size of the residuals is measured, default sse (e'e), but any Function such as norm, e->sum(abs,e) or e -> e'Q*e could be used.\nregularizer(p)=0: function for regularization. The structure of p is detailed below\nsolver Defaults to Optim.BFGS()\nstabilize_predictor=true: Modifies the estimated Kalman gain K in case A-KC is not stable by moving all unstable eigenvalues to the unit circle.\ndifficult=false: If the identification problem appears to be difficult and ends up in a local minimum, set this flag to true to solve an initial global optimization problem to supply a good initial guess. This is expected to take some time.\nkwargs: additional keyword arguments are sent to Optim.Options.\n\nReturn values\n\nsys::StateSpaceNoise: identified system. Can be converted to StateSpace by convert(StateSpace, sys) or ss(sys), but this will discard the Kalman gain matrix, see innovation_form to obtain a predictor system.\nx0: Estimated initial state\nopt: Optimization problem structure. Contains info of the result of the optimization problem\n\nStructure of parameter vector p\n\nThe parameter vector is of type ComponentVector and the fields A,B,K,x0 can be accessed as p.A etc. The internal storage is according to\n\nA = size(nx,nx)\nB = size(nx,nu)\nK = size(nx,ny)\nx0 = size(nx)\np = [A[:]; B[:]; K[:]; x0]\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}","page":"API","title":"ControlSystemIdentification.plr","text":"G, Gn = plr(d::AbstractIdData,na,nb,nc; initial_order = 20)\n\nPerform pseudo-linear regression to estimate a model on the form Ay = Bu + Cw The residual sequence is estimated by first estimating a high-order arx model, whereafter the estimated residual sequence is included in a second estimation problem. The return values are the estimated system model, and the estimated noise model. G and Gn will always have the same denominator polynomial.\n\narmax is an alias for plr. See also pem, ar, arx\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.predplot","page":"API","title":"ControlSystemIdentification.predplot","text":"predplot(sys, data, x0=nothing; ploty=true, plote=false)\n\nPlot system simulation and measured output to compare them. ploty determines whether or not to plot the measured signal plote determines whether or not to plot the residual\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.prefilter-Tuple{Any, ControlSystemIdentification.InputOutputData}","page":"API","title":"ControlSystemIdentification.prefilter","text":"prefilter(f, d::InputOutputData)\n\nApply filter coefficients to identification data\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}","page":"API","title":"ControlSystemIdentification.prefilter","text":"prefilter(d::AbstractIdData, responsetype::FilterType)\n\nFilter both input and output of the identification data using zero-phase filtering (filtfilt). Since both input and output is filtered, linear identification will not be affected in any other way than to focus the fit on the selected frequency range, i.e. the range that has high gain in the provided filter. Note, if the system that generated d is nonlinear, identification might be severely impacted by this transformation. Verify linearity with, e.g., coherenceplot.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}","page":"API","title":"ControlSystemIdentification.prefilter","text":"prefilter(d::AbstractIdData, l::Number, u::Number)\n\nFilter input and output with a bandpass filter between l and u Hz. If l = 0 a lowpass filter will be used, and if u = Inf a highpass filter will be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.ramp_in-Tuple{ControlSystemIdentification.InputOutputData, Int64}","page":"API","title":"ControlSystemIdentification.ramp_in","text":"ramp_in(d::InputOutputData, h::Int; rev = false)\n\nMultiply the initial h samples of input and output signals with a linearly increasing ramp.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.simplot","page":"API","title":"ControlSystemIdentification.simplot","text":"simplot(sys, data, x0=nothing; ploty=true, plote=false)\n\nPlot system simulation and measured output to compare them. ploty determines whether or not to plot the measured signal plote determines whether or not to plot the residual\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.simulate","page":"API","title":"ControlSystemIdentification.simulate","text":"simulate(sys, u, x0 = nothing)\nsimulate(sys, d, x0 = nothing)\n\nSee also simplot\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.specplot","page":"API","title":"ControlSystemIdentification.specplot","text":"specplot(d::IdData)\n\nPlot a spectrogram of the input and output timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any, N} where N}","page":"API","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(frd::FRD, args...; estimate_x0 = false, kwargs...)\n\nIf a frequency-reponse data object is supplied\n\nThe FRD will be automatically converted to an InputOutputFreqData\nestimate_x0 is by default set to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}","page":"API","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(\n    data::InputOutputData,\n    nx = :auto;\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used\n    s1 = r, # number of past outputs\n    s2 = r, # number of past inputs\n    W = :MOESP,\n    zeroD = false,\n    stable = true, \n    focus = :prediction,\n    svd::F1 = svd!,\n    scaleU = true,\n    Aestimator::F2 = \\,\n    Bestimator::F3 = \\,\n    weights = nothing,\n)\n\nEstimate a state-space model using subspace-based identification.\n\nRef: Ljung, Theory for the user.\n\nArguments:\n\ndata: Identification data iddata\nnx: Rank of the model (model order)\nverbose: Print stuff?\nr: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.\ns1: past horizon of outputs\ns2: past horizon of inputs\nW: Weight type, choose between :MOESP, :CVA, :N4SID, :IVM\nzeroD: Force the D matrix to be zero.\nstable: Stabilize unstable system using eigenvalue reflection.\nfocus: :prediction or simulation\nsvd: The function to use for svd\nscaleU: Rescale the input channels to have the same energy.\nAestimator: Estimator function used to estimate A,C.\nBestimator: Estimator function used to estimate B,D.\nweights: A vector of weights can be provided if the Bestimator is wls. \n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}","page":"API","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(data::InputOutputFreqData,\n    Ts = data.Ts,\n    nx = :auto;\n    cont = false,\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order\n    zeroD = false,\n    estimate_x0 = true,\n    stable = true, \n    svd = svd!,\n    Aestimator = \\,\n    Bestimator = \\,\n    weights = nothing\n)\n\nEstimate a state-space model using subspace-based identification in the frequency domain.\n\nArguments:\n\ndata: A frequency-domain identification data object.\nTs: Sample time at which the data was collected\nnx: Desired model order, an interer or :auto.\ncont: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function d2c.\nverbose: Print stuff?\nr: Internal model order, must be ≥ nx.\nzeroD: Force the D matrix to be zero.\nestimate_x0: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.\nstable: For the model to be stable (uses schur_stab).\nsvd: The svd function to use.\nAestimator: The estimator of the A matrix (and initial C-matrix).\nBestimator: The estimator of B/D and C/D matrices.\nweights: An optional vector of frequency weights of the same length as the number of frequencies in `data.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.tfest","page":"API","title":"ControlSystemIdentification.tfest","text":"H, N = tfest(data, σ = 0.05)\n\nEstimate a transfer function model using the Correlogram approach.     Both H and N are of type FRD (frequency-response data).\n\nσ determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger σ implies less smoothing.\n\nH = Syu/Suu             Process transfer function\nN = Sy - |Syu|²/Suu     Noise PSD\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.tfest","page":"API","title":"ControlSystemIdentification.tfest","text":"tfest(\n    data::FRD,\n    p0,\n    link = log ∘ abs;\n    freq_weight = sqrt(data.w[1]*data.w[end]),\n    refine = true,\n    opt = BFGS(),\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 1,\n        iterations        = 100,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 0,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n    ),\n)\n\nFit a parametric transfer function to frequency-domain data.\n\nThe initial pahse of the optimization solves\n\noperatornameminimize_BA Bl - A\n\nand the second stage (if refine=true) solves \n\noperatornameminimize_BA textlinkleft(dfracBAright) - textlinkleft(lright)\n\n(abs2(link(B/A) - link(l)))\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\np0: Initial parameter guess. Can be a NamedTuple or ComponentVector with fields b,a specifying numerator and denominator as they appear in the call to tf, i.e., (b = [1.0], a = [1.0,1.0,1.0]). Can also be an instace of TransferFunction.\nlink: By default, phase information is discarded in the fitting. To include phase, change to link = log.\nfreq_weight: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.\nrefine: Indicate whether or not a second optimization stage is performed to refine the results of the first.\nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\nSee also minimum_phase to transform a possibly non-minimum phase system to minimum phase.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M","page":"API","title":"ControlSystemIdentification.tfest","text":"tfest(data::FRD, basis::AbstractStateSpace; \n    freq_weight = 1 ./ (data.w .+ data.w[2]),\n    opt = BFGS(),\n    metric::M = abs2,\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 50,\n        iterations        = 1000000,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 1e-5,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n)\n\nFit a parametric transfer function to frequency-domain data using a pre-specified basis.\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\n\nfunction kautz(a::AbstractVector)\n\nbasis: A basis for the estimation. See, e.g., laguerre, laguerre_oo, kautz\nfreq_weight: A vector of weights per frequency. The default is approximately 1/f. \nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\n\n\n\n\n","category":"method"},{"location":"api/#ControlSystemIdentification.wtls_estimator","page":"API","title":"ControlSystemIdentification.wtls_estimator","text":"wtls_estimator(y,na,nb, σu=0)\n\nCreate an estimator function for estimation of arx models in the presence of measurement noise. If the noise variance on the input σu (model errors) is known, this can be specified for increased accuracy.\n\n\n\n\n\n","category":"function"},{"location":"api/#DSP.Filters.resample-Tuple{AbstractStateSpace{var\"#s254\"} where var\"#s254\"<:Discrete, AbstractMatrix{T} where T, Real}","page":"API","title":"DSP.Filters.resample","text":"DSP.resample(sys::AbstractStateSpace{<:Discrete}, Qd::AbstractMatrix, newh::Real)\n\nChange sample time of covariance matrix Qd beloning to sys to newh. This function does not handle the measurement covariance, how to do this depends on context. If the faster sampled signal has the same measurement noise, no change should be made. If the slower sampled signal was downsampled with filtering, the measurement covariance should be increased if the system is changed to a faster sample rate. To maintain the frequency response of the system, the measurement covariance should be modified accordinly.\n\nArguments:\n\nsys: A discrete-time system that has dynamics noise covariance matric Qd.\nQd: Covariance matrix of dynamics noise.\nnewh: The new sample time.\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Filters.resample-Tuple{AbstractStateSpace{var\"#s254\"} where var\"#s254\"<:Discrete, Real}","page":"API","title":"DSP.Filters.resample","text":"resample(sys::AbstractStateSpace{<:Discrete}, newh::Real)\n\nChange sample-time of sys to newh.\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}","page":"API","title":"DSP.Filters.resample","text":"dr = resample(d::InputOutputData, f)\n\nResample iddata d with fraction f, e.g., f = fs_new / fs_original.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}","page":"API","title":"StatsBase.predict","text":"predict(sys, d::AbstractIdData, args...)\npredict(sys, y, u, x0 = nothing)\n\nSee also predplot\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.predict-Tuple{TransferFunction, Any}","page":"API","title":"StatsBase.predict","text":"yh = predict(ar::TransferFunction, y)\n\nPredict AR model\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.predict-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}","page":"API","title":"StatsBase.predict","text":"predict(ARX::TransferFunction, d::InputOutputData)\n\nOne step ahead prediction for an ARX process.  The length of the returned prediction is length(d) - max(na, nb)\n\nExample:\n\njulia> predict(tf(1, [1, -1], 1), iddata(1:10, 1:10))\n9-element Vector{Int64}:\n  2\n  4\n  6\n  8\n 10\n 12\n 14\n 16\n 18\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsBase.residuals-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}","page":"API","title":"StatsBase.residuals","text":"residuals(ARX::TransferFunction, d::InputOutputData)\n\nCalculates the residuals v = Ay - Bu of an ARX process and InputOutputData d. The length of the returned residuals is length(d) - max(na, nb)\n\nExample:\n\njulia> ARX = tf(1, [1, -1], 1)\nTransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}\n  1\n-----\nz - 1\n\nSample Time: 1 (seconds)\nDiscrete-time transfer function model\n\njulia> u = 1:5\n1:5\n\njulia> y = lsim(ARX, u, 1:5)[1][:]\n5-element Vector{Float64}:\n  0.0\n  1.0\n  3.0\n  6.0\n 10.0\n\njulia> d = iddata(y, u)\nInputOutput data of length 5 with 1 outputs and 1 inputs\n\njulia> residuals(ARX, d)\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"ControlSystems.StateSpace\nDelimitedFiles.writedlm\nLowLevelParticleFilters.KalmanFilter","category":"page"},{"location":"api/#DelimitedFiles.writedlm","page":"API","title":"DelimitedFiles.writedlm","text":"DelimitedFiles.writedlm(io::IO, d::AbstractIdData, args...; kwargs...)\n\nWrite identification data to disk.\n\n\n\n\n\n","category":"function"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"A typical model for a temperature-controlled system is ","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"tau dot T = -T  + Bu + c","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"where T is the temperature, u the control signal and c a constant offset, e.g., related to the temperature surrounding the controlled system. The time constant tau captures the relation between stored energy and the resistance to heat flow and determines how fast the temperature is changing. This system can be written on transfer-function form like (omitting c)","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"dfracBtau s + 1U(s)","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"This is a simple first-order transfer function which can be estimated with, e.g., the functions arx or plr. To illustrate this, we create such a system and simulate some data from it.","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"using ControlSystems, ControlSystemIdentification, Plots\nw = 2pi .* exp10.(LinRange(-3, log10(0.5), 500))\nG0 = tf(1, [10, 1]) # The true system, 10ẋ = -x + u\nG = c2d(G0, 1)      # discretize with a sample time of 1s\nprintln(\"True system\")\ndisplay(G0)\n\nu = sign.(sin.((0:0.01:20) .^ 2))' # sample a control input for identification\ny, t, x = lsim(ss(G), u) # Simulate the true system to get test data\nyn = y .+ 0.2 .* randn.() # add measurement noise\ndata = iddata(yn, u, t[2] - t[1]) # create a data object\nplot(data)","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"We see that the data we're going to use for identification is a chirp input. Chirps are excellent for identification as they have a well defined and easily controllable interval of frequencies for identification. We start by inspecting the coherence plot to ensure that the data is suitable for identification of a linear system","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"coherenceplot(data, hz=true)","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"The coherence is high for all frequencies spanned by the chirp, after which it drops significantly. This implies that we can only ever trust the identified model to be accurate up to the highest frequency that was present in the chirp input.","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"Next we set the parameters for the estimation, the numerator and denominator have one parameter each, so we set n_a = n_b = 1 and estimate two models.","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"na, nb = 1, 1 # number of parameters in denominator and numerator\nGh = arx(data, na, nb, estimator = wtls_estimator(data.y, na, nb)) # estimate an arx model\nGh2, noise_model = plr(data, na, nb, 1) # try another identification method\n\nGh, Gh2","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"Least-squares estimation of ARX models from data with high measurement noise is known to lead to models with poor low-frequency fit, we therefore used the wtls_estimator(data.y, na, nb) which performs the estimation with total-least squares.","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"We can plot the results in several different ways:","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"# Plot results\nprintln(\"Estimated system in continuous time\")\ndisplay(d2c(Gh)) # Convert from discrete to continuous time","category":"page"},{"location":"examples/temp/#","page":"Temperature control","title":"Temperature control","text":"bp = bodeplot(G, w, lab = \"G (true)\", hz = true, l = 5)\nbodeplot!(Gh, w, lab = \"arx\", hz = true)\nbodeplot!(Gh2, w, lab = \"plr\", hz = true, ticks = :default)\n\nsp = plot(step(G, 150), lab=\"G (true)\")\nplot!(step(Gh, 150), lab = \"arx\")\nplot!(step(Gh2, 150), lab = \"plr\", ticks = :default)\nhline!([1], primary = false, l = (:black, :dash))\n\nlp = plot(lsim(ss(G), u), lab=\"G (true)\")\nplot!(lsim(ss(Gh), u), lab = \"arx\")\nplot!(lsim(ss(Gh2), u), lab = \"plr\", ticks = :default)\nplot!(data.t, yn[:], lab = \"Estimation data\")\n\nplot(bp, sp, lp, layout = @layout([[a b]; c]))","category":"page"},{"location":"ss/#LTI-state-space-models-1","page":"State-space estimation","title":"LTI state-space models","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"There exist several methods for identification of statespace models, subspaceid, n4sid and pem. subspaceid is the most comprehensive algorithm for subspace-based identification whereas n4sid is an older implementation. pem solves the prediction-error problem using an iterative optimization method (from Optim.jl). If unsure which method to use, try subspaceid first.","category":"page"},{"location":"ss/#Subspace-based-identification-using-n4sid-1","page":"State-space estimation","title":"Subspace-based identification using n4sid","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"d = iddata(y,u,sampletime)\nsys = n4sid(d, :auto; verbose=false)\n# or use a robust version of svd if y has outliers or missing values\nusing TotalLeastSquares\nsys = n4sid(d, :auto; verbose=false, svd=x->rpca(x)[3])","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"Estimate a statespace model using the n4sid method. Returns an object of type N4SIDResult where the model is accessed as sys.sys. The frequency-weighting functionality is borrowing ideas from \"Frequency Weighted Subspace Based System Identification in the Frequency Domain\", Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).","category":"page"},{"location":"ss/#ERA-and-OKID-1","page":"State-space estimation","title":"ERA and OKID","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"See era and okid.","category":"page"},{"location":"ss/#PEM-1","page":"State-space estimation","title":"PEM","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"A simple algorithm for identification of discrete-time LTI systems on state-space form:","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"x = Ax + Bu + Ke","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"y  = Cx + e","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"is provided. The user can choose to minimize either prediction errors or simulation errors, with arbitrary metrics, i.e., not limited to squared errors.","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"The result of the identification with pem is a custom type StateSpaceNoise <: ControlSystems.LTISystem, with fields A,B,K, representing the dynamics matrix, input matrix and Kalman gain matrix, respectively. The observation matrix C is not stored, as this is always given by [I 0] (you can still access it through sys.C thanks to getproperty).","category":"page"},{"location":"ss/#Usage-example-1","page":"State-space estimation","title":"Usage example","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"Below, we generate a system and simulate it forward in time. We then try to estimate a model based on the input and output sequences.","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"using ControlSystemIdentification, ControlSystems, Random, LinearAlgebra\nusing ControlSystemIdentification: newpem\nsys = c2d(tf(1, [1, 0.5, 1]) * tf(1, [1, 1]), 0.1)\n\nRandom.seed!(1)\nT   = 1000                      # Number of time steps\nnx  = 3                         # Number of poles in the true system\nx0  = randn(nx)                 # Initial state\nsim(sys,u,x0=x0) = lsim(ss(sys), u, x0=x0)[1] # Helper function\nu   = randn(nu,T)               # Generate random input\ny   = sim(sys, u, x0)           # Simulate system\nd   = iddata(y,u,0.1)\n\nsysh,opt = newpem(d, nx, focus=:prediction) # Estimate model\n\nyh = predict(sysh, d)      # Predict using estimated model\npredplot(sysh, d)   # Plot prediction and true output","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"See the example notebooks for more plots.","category":"page"},{"location":"ss/#Internals-1","page":"State-space estimation","title":"Internals","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"Internally, Optim.jl is used to optimize the system parameters, using automatic differentiation to calculate gradients (and Hessians where applicable). Optim solver options can be controlled by passing keyword arguments to pem, and by passing a manually constructed solver object. The default solver is BFGS()","category":"page"},{"location":"ss/#Filtering-and-simulation-1","page":"State-space estimation","title":"Filtering and simulation","text":"","category":"section"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"Models can be simulated using lsim from ControlSystems.jl and using simulate. You may also convert the model to a KalmanFilter from LowLevelParticleFilters.jl by calling KalmanFilter(sys), after which you can perform filtering and smoothing etc. with the utilities provided for a KalmanFilter.","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"Furthermore, we have the utility functions below","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"predict(sys, d, x0=zeros): Form predictions using estimated sys, this essentially runs a stationary Kalman filter.\nsimulate(sys, u, x0=zeros): Simulate the system using input u. The noise model and Kalman gain does not have any influence on the simulated output.\nobserver_predictor: Extract the predictor model from the estimated system (ss(A-KC,[B K],C,D)).\nobserver_controller\nprediction_error\npredictiondata\nnoise_model","category":"page"},{"location":"ss/#","page":"State-space estimation","title":"State-space estimation","text":"ControlSystemIdentification.subspaceid\nControlSystemIdentification.n4sid\nControlSystemIdentification.pem\nControlSystemIdentification.newpem\nControlSystemIdentification.era\nControlSystemIdentification.okid","category":"page"},{"location":"ss/#ControlSystemIdentification.subspaceid","page":"State-space estimation","title":"ControlSystemIdentification.subspaceid","text":"subspaceid(\n    data::InputOutputData,\n    nx = :auto;\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used\n    s1 = r, # number of past outputs\n    s2 = r, # number of past inputs\n    W = :MOESP,\n    zeroD = false,\n    stable = true, \n    focus = :prediction,\n    svd::F1 = svd!,\n    scaleU = true,\n    Aestimator::F2 = \\,\n    Bestimator::F3 = \\,\n    weights = nothing,\n)\n\nEstimate a state-space model using subspace-based identification.\n\nRef: Ljung, Theory for the user.\n\nArguments:\n\ndata: Identification data iddata\nnx: Rank of the model (model order)\nverbose: Print stuff?\nr: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.\ns1: past horizon of outputs\ns2: past horizon of inputs\nW: Weight type, choose between :MOESP, :CVA, :N4SID, :IVM\nzeroD: Force the D matrix to be zero.\nstable: Stabilize unstable system using eigenvalue reflection.\nfocus: :prediction or simulation\nsvd: The function to use for svd\nscaleU: Rescale the input channels to have the same energy.\nAestimator: Estimator function used to estimate A,C.\nBestimator: Estimator function used to estimate B,D.\nweights: A vector of weights can be provided if the Bestimator is wls. \n\n\n\n\n\nsubspaceid(frd::FRD, args...; estimate_x0 = false, kwargs...)\n\nIf a frequency-reponse data object is supplied\n\nThe FRD will be automatically converted to an InputOutputFreqData\nestimate_x0 is by default set to 0.\n\n\n\n\n\nsubspaceid(data::InputOutputFreqData,\n    Ts = data.Ts,\n    nx = :auto;\n    cont = false,\n    verbose = false,\n    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order\n    zeroD = false,\n    estimate_x0 = true,\n    stable = true, \n    svd = svd!,\n    Aestimator = \\,\n    Bestimator = \\,\n    weights = nothing\n)\n\nEstimate a state-space model using subspace-based identification in the frequency domain.\n\nArguments:\n\ndata: A frequency-domain identification data object.\nTs: Sample time at which the data was collected\nnx: Desired model order, an interer or :auto.\ncont: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function d2c.\nverbose: Print stuff?\nr: Internal model order, must be ≥ nx.\nzeroD: Force the D matrix to be zero.\nestimate_x0: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.\nstable: For the model to be stable (uses schur_stab).\nsvd: The svd function to use.\nAestimator: The estimator of the A matrix (and initial C-matrix).\nBestimator: The estimator of B/D and C/D matrices.\nweights: An optional vector of frequency weights of the same length as the number of frequencies in `data.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.n4sid","page":"State-space estimation","title":"ControlSystemIdentification.n4sid","text":"res = n4sid(data, r=:auto; verbose=false)\n\nEstimate a statespace model using the n4sid method. Returns an object of type N4SIDStateSpace where the model is accessed as res.sys.\n\nImplements the simplified algorithm (alg 2) from \"N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems\" PETER VAN OVERSCHEE and BART DE MOOR\n\nThe frequency weighting is borrowing ideas from \"Frequency Weighted Subspace Based System Identi\fcation in the Frequency Domain\", Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).\n\nArguments:\n\ndata: Identification data data = iddata(y,u)\nr: Rank of the model (model order)\nverbose: Print stuff?\nWf: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like Wf = Bandstop(lower, upper, fs=1/Ts) to indicate that there are disturbances outside this band.\ni: Algorithm parameter, generally no need to tune this\nγ: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.\nzeroD: defaults to false\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.pem","page":"State-space estimation","title":"ControlSystemIdentification.pem","text":"sys, x0, opt = pem(data; nx, kwargs...)\n\nSystem identification using the prediction-error method.\n\nArguments:\n\ndata: iddata object containing y and u.\ny: Measurements, either a matrix with time along dim 2, or a vector of vectors\nu: Control signals, same structure as y\nnx: Number of poles in the estimated system. Thus number should be chosen as number of system poles plus number of poles in noise models for measurement noise and load disturbances.\nfocus: Either :prediction or :simulation. If :simulation is chosen, a two stage problem is solved with prediction focus first, followed by a refinement for simulation focus.\nmetric: A Function determining how the size of the residuals is measured, default sse (e'e), but any Function such as norm, e->sum(abs,e) or e -> e'Q*e could be used.\nregularizer(p)=0: function for regularization. The structure of p is detailed below\nsolver Defaults to Optim.BFGS()\nstabilize_predictor=true: Modifies the estimated Kalman gain K in case A-KC is not stable by moving all unstable eigenvalues to the unit circle.\ndifficult=false: If the identification problem appears to be difficult and ends up in a local minimum, set this flag to true to solve an initial global optimization problem to supply a good initial guess. This is expected to take some time.\nkwargs: additional keyword arguments are sent to Optim.Options.\n\nReturn values\n\nsys::StateSpaceNoise: identified system. Can be converted to StateSpace by convert(StateSpace, sys) or ss(sys), but this will discard the Kalman gain matrix, see innovation_form to obtain a predictor system.\nx0: Estimated initial state\nopt: Optimization problem structure. Contains info of the result of the optimization problem\n\nStructure of parameter vector p\n\nThe parameter vector is of type ComponentVector and the fields A,B,K,x0 can be accessed as p.A etc. The internal storage is according to\n\nA = size(nx,nx)\nB = size(nx,nu)\nK = size(nx,ny)\nx0 = size(nx)\np = [A[:]; B[:]; K[:]; x0]\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.newpem","page":"State-space estimation","title":"ControlSystemIdentification.newpem","text":"newpem(\n    d,\n    nx;\n    zeroD = true,\n    sys0 = subspaceid(d, nx; zeroD),\n    focus = :prediction,\n    optimizer = BFGS(\n        alphaguess = LineSearches.InitialStatic(alpha = 1),\n        linesearch = LineSearches.HagerZhang(),\n    ),\n    zerox0 = false,\n    initx0 = false,\n    store_trace = true,\n    show_trace = true,\n    show_every = 50,\n    iterations = 10000,\n    allow_f_increases = false,\n    time_limit = 100,\n    x_tol = 0,\n    f_abstol = 0,\n    g_tol = 1e-12,\n    f_calls_limit = 0,\n    g_calls_limit = 0,\n)\n\nA new implementation of the prediction-error method (PEM). Note that this is an experimental implementation and subject to breaking changes not respecting semver.\n\nArguments:\n\nd: iddata\nnx: Model order\nzeroD: Force zero D matrix\nsys0: Initial guess, if non provided, subspaceid is used as initial guess.\nfocus: prediction or :simulation. If :simulation, hte K matrix will be zero.\noptimizer: One of Optim's optimizers\nzerox0: Force initial state to zero.\ninitx0: Estimate initial state once, otherwise at each iteration\n\nThe rest of the arguments are related to Optim.Options.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.era","page":"State-space estimation","title":"ControlSystemIdentification.era","text":"era(YY::AbstractArray{<:Any, 3}, Ts, r::Int, m::Int, n::Int)\n\nEigenvalue realization algorithm.\n\nArguments:\n\nYY: Markov parameters (impulse response) size n_out×n_in×n_time\nTs: Sample time\nr: Model order\nm: Number of rows in Hankel matrix\nn: Number of columns in Hankel matrix\n\n\n\n\n\nera(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r; p = l, λ=0)\n\nEigenvalue realization algorithm. Uses okid to find the Markov parameters as an initial step.\n\nArguments:\n\nr: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, for era, p defaults to l, while when calling okid directly, p defaults to 0.\n\n\n\n\n\n","category":"function"},{"location":"ss/#ControlSystemIdentification.okid","page":"State-space estimation","title":"ControlSystemIdentification.okid","text":"H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)\n\nObserver Kalman filter identification. Returns the Markov parameters H size n_out×n_in×l+1\n\nArguments:\n\nnx: Model order\nl: Number of Markov parameters to estimate.\nλ: Regularization parameter\np: Optionally, delete the first p columns in the internal Hankel matrices to account for initial conditions != 0. If x0 != 0, try setting p around the same value as l.\n\n\n\n\n\n","category":"function"},{"location":"validation/#Validation-1","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validation/#","page":"Validation","title":"Validation","text":"A number of functions are made available to assist in validation of the estimated models. We illustrate by an example","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"Generate some test data:","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"Random.seed!(1)\nT          = 200\nnx         = 2\nnu         = 1\nny         = 1\nx0         = randn(nx)\nσy         = 0.5\nsim(sys,u) = lsim(sys, u', 1:T)[1]'\nsys        = tf(1,[1,2*0.1,0.1])\nsysn       = tf(σy,[1,2*0.1,0.3])\n# Training data\nu          = randn(nu,T)\ny          = sim(sys, u)\nyn         = y + sim(sysn, randn(size(u)))\ndn         = iddata(yn,u,1)\n# Validation data\nuv         = randn(nu,T)\nyv         = sim(sys, uv)\nynv        = yv + sim(sysn, randn(size(uv)))\ndv         = iddata(yv,uv,1)\ndnv        = iddata(ynv,uv,1)","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"We then fit a couple of models, the flag difficult=true causes pem to solve an initial global optimization problem with constraints on the stability of A-KC to provide a good guess for the gradient-based solver","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"res = [pem(dn,nx=nx, iterations=1000, difficult=true, focus=:prediction) for nx = [1,3,4]]","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"After fitting the models, we validate the results using the validation data and the functions simplot and predplot (cf. Matlab sys.id's compare):","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"ω   = exp10.(range(-2, stop=log10(pi), length=150))\nfig = plot(layout=4, size=(1000,600))\nfor i in eachindex(res)\n    (sysh,x0h,opt) = res[i]\n    simplot!( sysh,dnv,x0h; subplot=1, ploty=i==1)\n    predplot!(sysh,dnv,x0h; subplot=2, ploty=i==1)\nend\nbodeplot!(ss.(getindex.(res,1)),                   ω, plotphase=false, subplot=3, title=\"Process\", linewidth=2*[4 3 2 1])\nbodeplot!(innovation_form.(getindex.(res,1)),      ω, plotphase=false, subplot=4, linewidth=2*[4 3 2 1])\nbodeplot!(sys,                                     ω, plotphase=false, subplot=3, lab=\"True\", linecolor=:blue, l=:dash, legend = :bottomleft, title=\"System model\")\nbodeplot!(innovation_form(ss(sys),syse=ss(sysn)),  ω, plotphase=false, subplot=4, lab=\"True\", linecolor=:blue, l=:dash, ylims=(0.1, 100), legend = :bottomleft, title=\"Noise model\")\ndisplay(fig)","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"(Image: window)","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"In the figure, simulation output is compared to the true model on the top left and prediction on top right. The system models and noise models are visualized in the bottom plots. Both high-order models capture the system dynamics well, but struggle slightly with capturing the gain of the noise dynamics. The figure also indicates that a model with 4 poles performs best on both prediction and simulation data. The true system has 4 poles (two in the process and two in the noise process) so this is expected. However, the third order model performs almost equally well and may be a better choice.","category":"page"},{"location":"validation/#","page":"Validation","title":"Validation","text":"See also simulate, predplot, simplot, coherenceplot","category":"page"},{"location":"impulse/#Impulse-response-estimation-1","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"","category":"section"},{"location":"impulse/#","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"The functions impulseest(h,y,u,order) and impulseestplot performs impulse-response estimation by fitting a high-order FIR model.","category":"page"},{"location":"impulse/#","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"Example","category":"page"},{"location":"impulse/#","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"T = 200\nh = 1\nt = h:h:T\nsim(sys,u) = lsim(sys, u, t)[1][:]\nsys = c2d(tf(1,[1,2*0.1,0.1]),h)\n\nu  = randn(length(t))\ny  = sim(sys, u)\nd  = iddata(y,u,h)\n\nimpulseestplot(d,50, lab=\"Estimate\")\nplot!(impulse(sys,50), lab=\"True system\")","category":"page"},{"location":"impulse/#","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"(Image: window)","category":"page"},{"location":"impulse/#","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"See the example notebooks for more details.","category":"page"},{"location":"impulse/#","page":"Impulse-response estimation","title":"Impulse-response estimation","text":"ControlSystemIdentification.impulseest\nControlSystemIdentification.impulseestplot","category":"page"},{"location":"impulse/#ControlSystemIdentification.impulseest","page":"Impulse-response estimation","title":"ControlSystemIdentification.impulseest","text":"ir, t, Σ = impulseest(d::AbstractIdData, n; λ=0, estimator=ls)\n\nEstimates the system impulse response by fitting an n:th order FIR model. Returns impulse-response estimate, time vector and covariance matrix. See also impulseestplot\n\n\n\n\n\n","category":"function"},{"location":"freq/#Transfer-function-estimation-using-spectral-techniques-1","page":"Frequency-domain estimation","title":"Transfer-function estimation using spectral techniques","text":"","category":"section"},{"location":"freq/#Nonparametric-estimation-1","page":"Frequency-domain estimation","title":"Nonparametric estimation","text":"","category":"section"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"Non-parametric estimation is provided through spectral estimation. To illustrate, we once again simulate some data:","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"T          = 100000\nh          = 1\nsim(sys,u) = lsim(sys, u, 1:T)[1][:]\nσy         = 0.5\nsys        = tf(1,[1,2*0.1,0.1])\nωn         = sqrt(0.3)\nsysn       = tf(σy*ωn,[1,2*0.1*ωn,ωn^2])\n\nu  = randn(T)\ny  = sim(sys, u)\nyn = y + sim(sysn, randn(size(u)))\nd  = iddata(y,u,h)\ndn = iddata(yn,u,h)","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"We can now estimate the coherence function to get a feel for whether or nor our data seems to be generated by a linear system:","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"k = coherence(d)  # Should be close to 1 if the system is linear and noise free\nk = coherence(dn) # Slightly lower values are obtained if the system is subject to measurement noise","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"We can also estimate a transfer function using spectral techniques, the main entry point to this is the function tfest, which returns a transfer-function estimate and an estimate of the power-spectral density of the noise (note, the unit of the PSD is squared compared to a transfer function, hence the √N when plotting it in the code below):","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"G,N = tfest(dn)\nbodeplot([sys,sysn], exp10.(range(-3, stop=log10(pi), length=200)), layout=(1,3), plotphase=false, subplot=[1,2,2], size=(3*800, 600), ylims=(0.1,300), linecolor=:blue)\n\ncoherenceplot!(dn, subplot=3)\nplot!(G, subplot=1, lab=\"G Est\", alpha=0.3, title=\"Process model\")\nplot!(√N, subplot=2, lab=\"N Est\", alpha=0.3, title=\"Noise model\")","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"(Image: window)","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"The left figure displays the Bode magnitude of the true system, together with the estimate (noisy), and the middle figure illustrates the estimated noise model. The right figure displays the coherence function (coherenceplot), which is close to 1 everywhere except for at the resonance peak of the noise log10(sqrt(0.3)) = -0.26.","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"See the example notebooks for more details.","category":"page"},{"location":"freq/#Parametric-estimation-1","page":"Frequency-domain estimation","title":"Parametric estimation","text":"","category":"section"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"To estimate a parametric, rational transfer function from frequency-domain data, call tfest with an FRD object and an initial guess for the system model. This initial guess determines the number of coefficients in the numerator and denominator of the estimated model.","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"G0 = tf(1.0, [1,1,1]) # Initial guess\nG = tfest(d::FRD, G0)","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"Internally, Optim is using a gradient-based optimizer to find the optimal fit of the bode curve of the system. The default optimizer BFGS can be changed, see the docstring ?tfest.","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"For a comparison between estimation in the time and frequency domains, see this notebook.","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"If the above problem is hard to solve, you may parametrize the model using, e.g., a Laguerre basis expansion, example:","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"basis = laguerre_oo(1, 50) # Use 50 basis functions, the final model order may be reduced with baltrunc\nGest,p = tfest(d::FRD, basis)","category":"page"},{"location":"freq/#Model-based-spectral-estimation-1","page":"Frequency-domain estimation","title":"Model-based spectral estimation","text":"","category":"section"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"The model estimation procedures can be used to estimate spectrograms. This package extends some methods from DSP.jl to accept a estimation function as the second argument. To create a suitable such function, we provide the function model_spectrum. Usage is illustrated below.","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"using ControlSystemIdentification, DSP\nT  = 1000\nfs = 1\ns = sin.((1:1/fs:T) .* 2pi/10) + 0.5randn(T)\nS1 = spectrogram(s,window=hanning, fs=fs)            # Standard spectrogram\nestimator = model_spectrum(ar,1/fs,6)\nS2 = spectrogram(s,estimator,window=rect, fs=fs)     # Model-based spectrogram\nplot(plot(S1,title=\"Standard Spectrogram\"),plot(S2,title=\"AR Spectrogram\")) # Requires the package LPVSpectral.jl","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"(Image: window)","category":"page"},{"location":"freq/#","page":"Frequency-domain estimation","title":"Frequency-domain estimation","text":"ControlSystemIdentification.tfest\nControlSystemIdentification.coherence\nControlSystemIdentification.laguerre_oo\nControlSystemIdentification.model_spectrum","category":"page"},{"location":"freq/#ControlSystemIdentification.tfest","page":"Frequency-domain estimation","title":"ControlSystemIdentification.tfest","text":"H, N = tfest(data, σ = 0.05)\n\nEstimate a transfer function model using the Correlogram approach.     Both H and N are of type FRD (frequency-response data).\n\nσ determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger σ implies less smoothing.\n\nH = Syu/Suu             Process transfer function\nN = Sy - |Syu|²/Suu     Noise PSD\n\n\n\n\n\ntfest(\n    data::FRD,\n    p0,\n    link = log ∘ abs;\n    freq_weight = sqrt(data.w[1]*data.w[end]),\n    refine = true,\n    opt = BFGS(),\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 1,\n        iterations        = 100,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 0,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n    ),\n)\n\nFit a parametric transfer function to frequency-domain data.\n\nThe initial pahse of the optimization solves\n\noperatornameminimize_BA Bl - A\n\nand the second stage (if refine=true) solves \n\noperatornameminimize_BA textlinkleft(dfracBAright) - textlinkleft(lright)\n\n(abs2(link(B/A) - link(l)))\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\np0: Initial parameter guess. Can be a NamedTuple or ComponentVector with fields b,a specifying numerator and denominator as they appear in the call to tf, i.e., (b = [1.0], a = [1.0,1.0,1.0]). Can also be an instace of TransferFunction.\nlink: By default, phase information is discarded in the fitting. To include phase, change to link = log.\nfreq_weight: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.\nrefine: Indicate whether or not a second optimization stage is performed to refine the results of the first.\nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\nSee also minimum_phase to transform a possibly non-minimum phase system to minimum phase.\n\n\n\n\n\ntfest(data::FRD, basis::AbstractStateSpace; \n    freq_weight = 1 ./ (data.w .+ data.w[2]),\n    opt = BFGS(),\n    metric::M = abs2,\n    opts = Optim.Options(\n        store_trace       = true,\n        show_trace        = true,\n        show_every        = 50,\n        iterations        = 1000000,\n        allow_f_increases = false,\n        time_limit        = 100,\n        x_tol             = 1e-5,\n        f_tol             = 0,\n        g_tol             = 1e-8,\n        f_calls_limit     = 0,\n        g_calls_limit     = 0,\n)\n\nFit a parametric transfer function to frequency-domain data using a pre-specified basis.\n\nArguments:\n\ndata: An FRD onbject with frequency domain data.\n\nfunction kautz(a::AbstractVector)\n\nbasis: A basis for the estimation. See, e.g., laguerre, laguerre_oo, kautz\nfreq_weight: A vector of weights per frequency. The default is approximately 1/f. \nopt: The Optim optimizer to use.\nopts: Optim.Options controlling the solver options.\n\n\n\n\n\n","category":"function"},{"location":"freq/#ControlSystemIdentification.coherence","page":"Frequency-domain estimation","title":"ControlSystemIdentification.coherence","text":"κ = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming)\n\nCalculates the magnitude-squared coherence Function. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ << 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy. κ: Coherence function (not squared) N: Noise model\n\n\n\n\n\n","category":"function"},{"location":"freq/#ControlSystemIdentification.laguerre_oo","page":"Frequency-domain estimation","title":"ControlSystemIdentification.laguerre_oo","text":"laguerre_oo(a::Number, Nq)\n\nConstruct an output orthogonalized Laguerre basis of length Nq with poles at a.\n\n\n\n\n\n","category":"function"},{"location":"freq/#ControlSystemIdentification.model_spectrum","page":"Frequency-domain estimation","title":"ControlSystemIdentification.model_spectrum","text":"model_spectrum(f, h, args...; kwargs...)\n\nArguments:\n\nf: the model-estimation function, e.g., ar,arma\nh: The sample time\nargs: arguments to f\nkwargs: keyword arguments to f\n\nExample:\n\nusing ControlSystemIdentification, DSP\nT = 1000\ns = sin.((1:T) .* 2pi/10)\nS1 = spectrogram(s,window=hanning)\nestimator = model_spectrum(ar,1,2)\nS2 = spectrogram(s,estimator,window=rect)\nplot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl\n\n\n\n\n\n","category":"function"},{"location":"#ControlSystemIdentification-1","page":"Home","title":"ControlSystemIdentification","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"System identification for ControlSystems.jl. Examples in the form of jupyter notebooks are provided here.","category":"page"},{"location":"#Other-resources-1","page":"Home","title":"Other resources","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For estimation of linear time-varying models (LTV), see LTVModels.jl.\nFor estimation of linear and nonlinear grey-box models in continuous time, see DifferentialEquations.jl (parameter estimation)\nEstimation of nonlinear black-box models in continuous time DiffEqFlux.jl and in discrete time Flux.jl\nFor more advanced spectral estimation, cross coherence, etc., see LPVSpectral.jl\nThis package interacts well with MonteCarloMeasurements.jl. See example file.\nState estimation is facilitated by LowLevelParticleFilters.jl.","category":"page"},{"location":"iddata/#Identification-data-1","page":"Identification data","title":"Identification data","text":"","category":"section"},{"location":"iddata/#","page":"Identification data","title":"Identification data","text":"All estimation methods in this package expects an object of type AbstractIdData, created using the function iddata. This object typically holds input and output data as well as the sample time. ","category":"page"},{"location":"iddata/#","page":"Identification data","title":"Identification data","text":"ControlSystemIdentification.iddata\nControlSystemIdentification.predictiondata","category":"page"},{"location":"iddata/#ControlSystemIdentification.iddata","page":"Identification data","title":"ControlSystemIdentification.iddata","text":"iddata(y::AbstractArray, u::AbstractArray, w::AbstractVector)\n\nCreate a frequency-domain input-output data object. w is expected to be in rad/s.\n\n\n\n\n\niddata(y,       Ts = nothing)\niddata(y, u,    Ts = nothing)\niddata(y, u, x, Ts = nothing)\n\nReturns the appropriate identification-data object, depending on the input.\n\nArguments\n\ny::AbstractArray: output data (required)\nu::AbstractArray: input data (if available)\nx::AbstractArray: state data (if available)\nTs::Union{Real,Nothing} = nothing: optional sample time\n\nIf the time-series are multivariate, time is in the last dimension.\n\nOperations on iddata\n\nprefilter\nresample\nappend two along the time dimension [d1 d2]\nindex time series d[output_index, input_index]\nindex the time axis with indices d[time_indices]\nindex the time axis with seconds d[3Sec:12Sec] (using ControlSystemIdentification: Sec)\naccess number of inputs, outputs and sample time: d.nu, d.ny, d.Ts\naccess the time time vector d.t\npremultiply to scale outputs C * d\npostmultiply to scale inputs d * B\nwritedlm\nramp_in, ramp_out\nplot\nspecplot\n\nExamples\n\njulia> iddata(randn(10))\nOutput data of length 10 with 1 outputs\n\njulia> iddata(randn(10), randn(10), 1)\nInputOutput data of length 10 with 1 outputs and 1 inputs\n\njulia> d = iddata(randn(2, 10), randn(3, 10), 0.1)\nInputOutput data of length 10 with 2 outputs and 3 inputs\n\njulia> [d d] # Concatenate along time\nInputOutput data of length 20 with 2 outputs and 3 inputs\n\njulia> d[1:3]\nInputOutput data of length 3 with 2 outputs and 3 inputs\n\njulia> d.nu\n3\n\njulia> d.t # access time vector\n0.0:0.1:0.9\n\n\n\n\n\n","category":"function"},{"location":"iddata/#ControlSystemIdentification.predictiondata","page":"Identification data","title":"ControlSystemIdentification.predictiondata","text":"predictiondata(d::AbstractIdData)\n\nAdd the output y to the input u_new = [u; y]\n\n\n\n\n\n","category":"function"},{"location":"iddata/#","page":"Identification data","title":"Identification data","text":"Some frequency-domain methods accept or return objects of type FRD, representing frequency-response data","category":"page"},{"location":"iddata/#","page":"Identification data","title":"Identification data","text":"ControlSystemIdentification.FRD","category":"page"}]
}

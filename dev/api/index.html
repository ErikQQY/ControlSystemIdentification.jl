<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ControlSystemIdentification Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ControlSystemIdentification Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../iddata/">Identification data</a></li><li><a class="tocitem" href="../ss/">State-space estimation</a></li><li><a class="tocitem" href="../tf/">Transfer-function estimation</a></li><li><a class="tocitem" href="../impulse/">Impulse-response estimation</a></li><li><a class="tocitem" href="../freq/">Frequency-domain estimation</a></li><li><a class="tocitem" href="../validation/">Validation</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/temp/">Temperature control</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types-1"><a class="docs-heading-anchor" href="#Exported-functions-and-types-1">Exported functions and types</a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types-1" title="Permalink"></a></h1><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#ControlSystemIdentification.FRD"><code>ControlSystemIdentification.FRD</code></a></li><li><a href="#ControlSystemIdentification.Hz"><code>ControlSystemIdentification.Hz</code></a></li><li><a href="#ControlSystemIdentification.N4SIDStateSpace"><code>ControlSystemIdentification.N4SIDStateSpace</code></a></li><li><a href="#ControlSystemIdentification.rad"><code>ControlSystemIdentification.rad</code></a></li><li><a href="#ControlSystemIdentification.apply_fun"><code>ControlSystemIdentification.apply_fun</code></a></li><li><a href="../tf/#ControlSystemIdentification.ar"><code>ControlSystemIdentification.ar</code></a></li><li><a href="#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.ar</code></a></li><li><a href="#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma</code></a></li><li><a href="../tf/#ControlSystemIdentification.arma"><code>ControlSystemIdentification.arma</code></a></li><li><a href="#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma_ssa</code></a></li><li><a href="../tf/#ControlSystemIdentification.arx"><code>ControlSystemIdentification.arx</code></a></li><li><a href="#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arx</code></a></li><li><a href="#ControlSystemIdentification.arxar-Tuple{ControlSystemIdentification.InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}"><code>ControlSystemIdentification.arxar</code></a></li><li><a href="../tf/#ControlSystemIdentification.arxar"><code>ControlSystemIdentification.arxar</code></a></li><li><a href="#ControlSystemIdentification.coherence-Tuple{Any}"><code>ControlSystemIdentification.coherence</code></a></li><li><a href="../freq/#ControlSystemIdentification.coherence"><code>ControlSystemIdentification.coherence</code></a></li><li><a href="#ControlSystemIdentification.coherenceplot"><code>ControlSystemIdentification.coherenceplot</code></a></li><li><a href="#ControlSystemIdentification.crosscorplot"><code>ControlSystemIdentification.crosscorplot</code></a></li><li><a href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="#ControlSystemIdentification.era-Tuple{AbstractArray{var&quot;#s246&quot;, 3} where var&quot;#s246&quot;, Any, Int64, Int64, Int64}"><code>ControlSystemIdentification.era</code></a></li><li><a href="../ss/#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a></li><li><a href="#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>ControlSystemIdentification.estimate_residuals</code></a></li><li><a href="#ControlSystemIdentification.estimate_x0"><code>ControlSystemIdentification.estimate_x0</code></a></li><li><a href="#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{var&quot;#s252&quot;} where var&quot;#s252&quot;&lt;:Discrete, AbstractMatrix{T} where T}"><code>ControlSystemIdentification.filter_bank</code></a></li><li><a href="#ControlSystemIdentification.find_na"><code>ControlSystemIdentification.find_na</code></a></li><li><a href="#ControlSystemIdentification.find_nanb"><code>ControlSystemIdentification.find_nanb</code></a></li><li><a href="#ControlSystemIdentification.find_similarity_transform"><code>ControlSystemIdentification.find_similarity_transform</code></a></li><li><a href="../tf/#ControlSystemIdentification.getARXregressor"><code>ControlSystemIdentification.getARXregressor</code></a></li><li><a href="#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Any, Any}"><code>ControlSystemIdentification.getARXregressor</code></a></li><li><a href="#ControlSystemIdentification.getARregressor-Tuple{AbstractVector{T} where T, Any}"><code>ControlSystemIdentification.getARregressor</code></a></li><li><a href="../tf/#ControlSystemIdentification.getARregressor"><code>ControlSystemIdentification.getARregressor</code></a></li><li><a href="../iddata/#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector{T} where T}"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a></li><li><a href="#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.impulseest</code></a></li><li><a href="../impulse/#ControlSystemIdentification.impulseest"><code>ControlSystemIdentification.impulseest</code></a></li><li><a href="#ControlSystemIdentification.impulseestplot"><code>ControlSystemIdentification.impulseestplot</code></a></li><li><a href="#ControlSystemIdentification.kautz-Tuple{AbstractVector{T} where T, Any}"><code>ControlSystemIdentification.kautz</code></a></li><li><a href="#ControlSystemIdentification.laguerre-Tuple{Any, Any}"><code>ControlSystemIdentification.laguerre</code></a></li><li><a href="../freq/#ControlSystemIdentification.laguerre_oo"><code>ControlSystemIdentification.laguerre_oo</code></a></li><li><a href="#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}"><code>ControlSystemIdentification.laguerre_oo</code></a></li><li><a href="#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous, S} where S&lt;:(ControlSystems.SisoTf{T} where T)}"><code>ControlSystemIdentification.minimum_phase</code></a></li><li><a href="../freq/#ControlSystemIdentification.model_spectrum"><code>ControlSystemIdentification.model_spectrum</code></a></li><li><a href="#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any, N} where N}"><code>ControlSystemIdentification.model_spectrum</code></a></li><li><a href="../ss/#ControlSystemIdentification.n4sid"><code>ControlSystemIdentification.n4sid</code></a></li><li><a href="#ControlSystemIdentification.n4sid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.n4sid</code></a></li><li><a href="../ss/#ControlSystemIdentification.newpem"><code>ControlSystemIdentification.newpem</code></a></li><li><a href="#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}"><code>ControlSystemIdentification.noise_model</code></a></li><li><a href="../ss/#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a></li><li><a href="#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a></li><li><a href="../ss/#ControlSystemIdentification.pem"><code>ControlSystemIdentification.pem</code></a></li><li><a href="#ControlSystemIdentification.pem-Tuple{Any}"><code>ControlSystemIdentification.pem</code></a></li><li><a href="#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}"><code>ControlSystemIdentification.plr</code></a></li><li><a href="../tf/#ControlSystemIdentification.plr"><code>ControlSystemIdentification.plr</code></a></li><li><a href="../iddata/#ControlSystemIdentification.predictiondata"><code>ControlSystemIdentification.predictiondata</code></a></li><li><a href="#ControlSystemIdentification.predplot"><code>ControlSystemIdentification.predplot</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{Any, ControlSystemIdentification.InputOutputData}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}"><code>ControlSystemIdentification.prefilter</code></a></li><li><a href="#ControlSystemIdentification.ramp_in-Tuple{ControlSystemIdentification.InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_in</code></a></li><li><a href="#ControlSystemIdentification.simplot"><code>ControlSystemIdentification.simplot</code></a></li><li><a href="#ControlSystemIdentification.simulate"><code>ControlSystemIdentification.simulate</code></a></li><li><a href="#ControlSystemIdentification.specplot"><code>ControlSystemIdentification.specplot</code></a></li><li><a href="../ss/#ControlSystemIdentification.subspaceid"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any, N} where N}"><code>ControlSystemIdentification.subspaceid</code></a></li><li><a href="#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="../freq/#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a></li><li><a href="#ControlSystemIdentification.wtls_estimator"><code>ControlSystemIdentification.wtls_estimator</code></a></li><li><a href="#DSP.Filters.resample-Tuple{AbstractStateSpace{var&quot;#s254&quot;} where var&quot;#s254&quot;&lt;:Discrete, Real}"><code>DSP.Filters.resample</code></a></li><li><a href="#DSP.Filters.resample-Tuple{AbstractStateSpace{var&quot;#s254&quot;} where var&quot;#s254&quot;&lt;:Discrete, AbstractMatrix{T} where T, Real}"><code>DSP.Filters.resample</code></a></li><li><a href="#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>DSP.Filters.resample</code></a></li><li><a href="#DelimitedFiles.writedlm"><code>DelimitedFiles.writedlm</code></a></li><li><a href="#StatsAPI.predict-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}"><code>StatsAPI.predict</code></a></li><li><a href="#StatsAPI.predict-Tuple{TransferFunction, Any}"><code>StatsAPI.predict</code></a></li><li><a href="#StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}"><code>StatsAPI.predict</code></a></li><li><a href="#StatsAPI.residuals-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}"><code>StatsAPI.residuals</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.FRD" href="#ControlSystemIdentification.FRD"><code>ControlSystemIdentification.FRD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FRD(w,r)</code></pre><p>Represents frequency-response data. <code>w</code> holds the frequency vector and <code>r</code> the response. Methods defined on this type include</p><ul><li><code>+-*</code></li><li><code>length, vec, sqrt</code></li><li><code>plot</code></li><li><a href="@ref"><code>feedback</code></a></li><li><a href="@ref"><code>freqvec</code></a></li><li><a href="../freq/#ControlSystemIdentification.tfest"><code>tfest</code></a> to estimate a rational model</li><li>Indexing in the frequency domain using, e.g., <code>G[1Hz : 5Hz]</code>, <code>G[1rad : 5rad]</code></li></ul><p>If <code>r</code> represents a MIMO frequency response, the dimensions are <code>ny × nu × nω</code>. <code>freqresp</code> returns a <code>PermutedDimsArray</code> whose <code>.parent</code> field follows this convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frd.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.Hz" href="#ControlSystemIdentification.Hz"><code>ControlSystemIdentification.Hz</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents frequencies in Herz for indexing of <code>FRD</code> objects: <code>frd[2Hz:10Hz]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frd.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.N4SIDStateSpace" href="#ControlSystemIdentification.N4SIDStateSpace"><code>ControlSystemIdentification.N4SIDStateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">N4SIDStateSpace &lt;: AbstractPredictionStateSpace</code></pre><p>The result of statespace model estimation using the <code>n4sid</code> method.</p><p><strong>Fields:</strong></p><ul><li><code>sys</code>: estimated model in the form of a <a href="@ref"><code>StateSpace</code></a> object</li><li><code>Q</code>: estimated covariance matrix of the states</li><li><code>R</code>: estimated covariance matrix of the measurements</li><li><code>S</code>: estimated cross covariance matrix between states and measurements</li><li><code>K</code>: kalman observer gain</li><li><code>P</code>: solution to the Riccatti equation</li><li><code>x</code>: estimated state trajectory</li><li><code>s</code>: singular values</li><li><code>fve</code>: Fraction of variance explained by singular values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L381-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.rad" href="#ControlSystemIdentification.rad"><code>ControlSystemIdentification.rad</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents frequencies in rad/s for indexing of <code>FRD</code> objects: <code>frd[2rad:10rad]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frd.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.apply_fun" href="#ControlSystemIdentification.apply_fun"><code>ControlSystemIdentification.apply_fun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_fun(fun, d::InputOutputData)</code></pre><p>Apply <code>fun(y)</code> to all time series <code>y[,u,[x]] ∈ d</code> and return a new <code>iddata</code> with the transformed series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}" href="#ControlSystemIdentification.ar-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.ar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ar(d::AbstractIdData, na; λ=0, estimator=\, scaleB=false, stochastic=false)</code></pre><p>Estimate an AR transfer function <code>G = 1/A</code>, the AR process is defined as <code>A(z⁻¹)y(t) = e(t)</code></p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: IdData, see <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>na</code>: order of the model</li><li><code>λ</code>: <code>λ &gt; 0</code> can be provided for L₂ regularization</li><li><code>estimator</code>: e.g. <code>\,tls,irls,rtls</code></li><li><code>scaleB</code>: Whether or not to scale the numerator using the variance of the prediction error.</li><li><code>stochastic</code>: if true, returns a transfer function with uncertain parameters represented by <code>MonteCarloMeasurements.Particles</code>.</li></ul><p>Estimation of AR models using least-squares is known to struggle with heavy measurement noise, using <code>estimator = tls</code> can improve the result in this case.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; N = 10000
10000

julia&gt; e = [-0.2; zeros(N-1)] # noise e
10000-element Vector{Float64}:
[...]

julia&gt; G = tf([1, 0], [1, -0.9], 1) # AR transfer function
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
   1.0z
----------
1.0z - 0.9

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; y = lsim(G, e, 1:N)[1][:] # Get output of AR transfer function from input noise e
10000-element Vector{Float64}:
[...]

julia&gt; Gest = ar(iddata(y), 1) # Estimate AR transfer function from output y
TransferFunction{Discrete{Float64}, ControlSystems.SisoRational{Float64}}
          1.0z
-------------------------
1.0z - 0.8999999999999998

Sample Time: 1.0 (seconds)
Discrete-time transfer function model

julia&gt; G ≈ Gest # Test if estimation was correct
true

julia&gt; eest = lsim(1/Gest, y, 1:N)[1][:] # recover the input noise e from output y and estimated transfer function Gest
10000-element Vector{Float64}:
[...]

julia&gt; isapprox(eest, e, atol = eps()) # input noise correct recovered
true </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L187-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}" href="#ControlSystemIdentification.arma-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model = arma(d::AbstractIdData, na, nc; initial_order=20, method=:ls)</code></pre><p>Estimate a Autoregressive Moving Average model with <code>na</code> coefficients in the denominator and <code>nc</code> coefficients in the numerator. Returns the model and the estimated noise sequence driving the system.</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: iddata</li><li><code>initial_order</code>: An initial AR model of this order is used to estimate the residuals</li><li><code>estimator</code>: A function <code>(A,y)-&gt;minimizeₓ(Ax-y)</code> default is <code>\</code> but another option is <code>wtls_estimator(1:length(y)-initial_order,na,nc,ones(nc))</code></li></ul><p>See also <a href="../api/#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>estimate_residuals</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L542-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}" href="#ControlSystemIdentification.arma_ssa-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arma_ssa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arma_ssa(d::AbstractIdData, na, nc; L=nothing, estimator=\, robust=false)</code></pre><p>DOCSTRING</p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: iddata</li><li><code>na</code>: number of denominator parameters</li><li><code>nc</code>: number of numerator parameters</li><li><code>L</code>: length of the lag-embedding used to separate signal and noise. <code>nothing</code> corresponds to automatic selection.</li><li><code>estimator</code>: The function to solve the least squares problem. Examples <code>\,tls,irls,rtls</code>.</li><li><code>robust</code>: Use robust PCA to be resistant to outliers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L788-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}" href="#ControlSystemIdentification.arx-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any}"><code>ControlSystemIdentification.arx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Gtf = arx(d::AbstractIdData, na, nb; inputdelay = ones(Int, size(nb)), λ = 0, estimator=\, stochastic=false)</code></pre><p>Fit a transfer Function to data using an ARX model and equation error minimization.</p><ul><li><code>nb</code> and <code>na</code> are the number of coefficients of the numerator and denominator polynomials.</li></ul><p>Input delay can be added via <code>inputdelay = d</code>, which corresponds to an additional delay of <code>z^-d</code>. An <code>inputdelay = 0</code> results in a direct term. The highest order of the B polynomial is given by <code>nb + inputdelay - 1</code>.  <code>λ &gt; 0</code> can be provided for L₂ regularization. <code>estimator</code> defaults to \ (least squares), alternatives are <code>estimator = tls</code> for total least-squares estimation.  <code>arx(Δt,yn,u,na,nb, estimator=wtls_estimator(y,na,nb)</code> is potentially more robust in the presence of heavy measurement noise. The number of free parameters is <code>na+nb</code> </p><ul><li><code>stochastic</code>: if true, returns a transfer function with uncertain parameters represented by <code>MonteCarloMeasurements.Particles</code>.</li></ul><p>Supports MISO estimation by supplying an iddata with a matrix <code>u</code>, with nb = [nb₁, nb₂...] and optional inputdelay = [d₁, d₂...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.arxar-Tuple{ControlSystemIdentification.InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}" href="#ControlSystemIdentification.arxar-Tuple{ControlSystemIdentification.InputOutputData, Int64, Union{Int64, AbstractVector{Int64}}, Int64}"><code>ControlSystemIdentification.arxar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">G, H, e = arxar(d::InputOutputData, na::Int, nb::Union{Int, Vector{Int}}, nd::Int)</code></pre><p>Estimate the ARXAR model <code>Ay = Bu + v</code>, where <code>v = He</code> and <code>H = 1/D</code>, using generalized least-squares method. For more information see Söderström - Convergence properties of the generalized least squares identification method, 1974. </p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: iddata</li><li><code>na</code>: order of A</li><li><code>nb</code>: number of coefficients in B, the order is determined by <code>nb + inputdelay - 1</code>. In MISO estimation it takes the form <code>nb = [nb₁, nb₂...]</code>. </li><li><code>nd</code>: order of D</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>H = nothing</code>: prior knowledge about the AR noise model</li><li><code>inputdelay = ones(Int, size(nb))</code>: optional delay of input, inputdelay = 0 results in a direct term, takes the form inputdelay = [d₁, d₂...] in MISO estimation </li><li><code>λ = 0</code>: <code>λ &gt; 0</code> can be provided for L₂ regularization</li><li><code>estimator = \</code>: e.g. <code>\,tls,irls,rtls</code>, the latter three require <code>using TotalLeastSquares</code></li><li><code>δmin = 10e-4</code>: Minimal change in the power of e, that specifies convergence.</li><li><code>iterations = 10</code>: maximum number of iterations.</li><li><code>verbose = false</code>: if true, more information is printed</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">julia&gt; N = 500 
500

julia&gt; sim(G, u) = lsim(G, u, 1:N)[1][:]
sim (generic function with 1 method)

julia&gt; A = tf([1, -0.8], [1, 0], 1)
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
1.0z - 0.8
----------
   1.0z

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; B = tf([0, 1], [1, 0], 1)
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}
1
-
z

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; G = minreal(B / A)
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
   1.0
----------
1.0z - 0.8

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; D = tf([1, 0.7], [1, 0], 1)
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
1.0z + 0.7
----------
   1.0z

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; H = 1 / D
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
   1.0z
----------
1.0z + 0.7

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; u, e = randn(1, N), randn(1, N)
[...]

julia&gt; y, v = sim(G, u), sim(H * (1/A), e) # simulate process
[...]

julia&gt; d = iddata(y .+ v, u, 1)
InputOutput data of length 500 with 1 outputs and 1 inputs

julia&gt; na, nb , nd = 1, 1, 1
(1, 1, 1)

julia&gt; Gest, Hest, res = arxar(d, na, nb, nd)
(G = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
   0.9987917259291642
-------------------------
1.0z - 0.7937837464682017

Sample Time: 1 (seconds)
Discrete-time transfer function model, H = TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Float64}}
          1.0z
-------------------------
1.0z + 0.7019519225937721

Sample Time: 1 (seconds)
Discrete-time transfer function model, e = [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L262-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.coherence-Tuple{Any}" href="#ControlSystemIdentification.coherence-Tuple{Any}"><code>ControlSystemIdentification.coherence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">κ = coherence(d; n = length(d)÷10, noverlap = n÷2, window=hamming)</code></pre><p>Calculates the magnitude-squared coherence Function. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ &lt;&lt; 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy. κ: Coherence function (not squared) N: Noise model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frd.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.coherenceplot" href="#ControlSystemIdentification.coherenceplot"><code>ControlSystemIdentification.coherenceplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coherenceplot(d, [(;n=..., noverlap=...); hz=false)</code></pre><p>Calculates and plots the (squared) coherence Function κ. κ close to 1 indicates a good explainability of energy in the output signal by energy in the input signal. κ &lt;&lt; 1 indicates that either the system is nonlinear, or a strong noise contributes to the output energy.</p><p><code>hz</code> indicates Hertz instead of rad/s</p><p>Keyword arguments to <code>coherence</code> are supplied as a named tuple as a second positional argument .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L200-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.crosscorplot" href="#ControlSystemIdentification.crosscorplot"><code>ControlSystemIdentification.crosscorplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crosscorplot(data, [lags])</code></pre><p>Plot the cross correlation betweein input and output for <code>lags</code> that default to 10% of the length of the dataset on the negative side and 50% on the positive side but no more than 100 on each side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.era" href="#ControlSystemIdentification.era"><code>ControlSystemIdentification.era</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">era(d::AbstractIdData, r, m = 2r, n = 2r, l = 5r; p = l, λ=0)</code></pre><p>Eigenvalue realization algorithm. Uses <code>okid</code> to find the Markov parameters as an initial step.</p><p><strong>Arguments:</strong></p><ul><li><code>r</code>: Model order</li><li><code>l</code>: Number of Markov parameters to estimate.</li><li><code>λ</code>: Regularization parameter</li><li><code>p</code>: Optionally, delete the first <code>p</code> columns in the internal Hankel matrices to account for initial conditions != 0. If <code>x0 != 0</code>, for <code>era</code>, <code>p</code> defaults to <code>l</code>, while when calling <code>okid</code> directly, <code>p</code> defaults to 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace.jl#L359-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.era-Tuple{AbstractArray{var&quot;#s246&quot;, 3} where var&quot;#s246&quot;, Any, Int64, Int64, Int64}" href="#ControlSystemIdentification.era-Tuple{AbstractArray{var&quot;#s246&quot;, 3} where var&quot;#s246&quot;, Any, Int64, Int64, Int64}"><code>ControlSystemIdentification.era</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">era(YY::AbstractArray{&lt;:Any, 3}, Ts, r::Int, m::Int, n::Int)</code></pre><p>Eigenvalue realization algorithm.</p><p><strong>Arguments:</strong></p><ul><li><code>YY</code>: Markov parameters (impulse response) size <code>n_out×n_in×n_time</code></li><li><code>Ts</code>: Sample time</li><li><code>r</code>: Model order</li><li><code>m</code>: Number of rows in Hankel matrix</li><li><code>n</code>: Number of columns in Hankel matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace.jl#L309-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}" href="#ControlSystemIdentification.estimate_residuals-Tuple{Any, Any}"><code>ControlSystemIdentification.estimate_residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimate_residuals(model, y)</code></pre><p>Estimate the residuals driving the dynamics of an ARMA model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L824-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.estimate_x0" href="#ControlSystemIdentification.estimate_x0"><code>ControlSystemIdentification.estimate_x0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_x0(sys, d, n = min(length(d), 3 * slowest_time_constant(sys)))</code></pre><p>Estimate the initial state of the system </p><p><strong>Arguments:</strong></p><ul><li><code>d</code>: <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>n</code>: Number of samples to use.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{var&quot;#s252&quot;} where var&quot;#s252&quot;&lt;:Discrete, AbstractMatrix{T} where T}" href="#ControlSystemIdentification.filter_bank-Tuple{AbstractStateSpace{var&quot;#s252&quot;} where var&quot;#s252&quot;&lt;:Discrete, AbstractMatrix{T} where T}"><code>ControlSystemIdentification.filter_bank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter_bank(basis::AbstractStateSpace{&lt;:Discrete}, signal::AbstractMatrix)</code></pre><p>Filter <code>signal</code> through all systems in <code>basis</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/basis_functions.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.find_na" href="#ControlSystemIdentification.find_na"><code>ControlSystemIdentification.find_na</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_na(y::AbstractVector,n::Int)</code></pre><p>Plots the RMSE and AIC For model orders up to <code>n</code>. Useful for model selection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L327-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.find_nanb" href="#ControlSystemIdentification.find_nanb"><code>ControlSystemIdentification.find_nanb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_nanb(d::InputOutputData,na,nb)</code></pre><p>Plots the RMSE and AIC For model orders up to <code>n</code>. Useful for model selection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L351-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.find_similarity_transform" href="#ControlSystemIdentification.find_similarity_transform"><code>ControlSystemIdentification.find_similarity_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_similarity_transform(sys1, sys2)</code></pre><p>Find T such that <code>ControlSystems.similarity_transform(sys1, T) == sys2</code></p><p>Ref: Minimal state-space realization in linear system theory: an overview, B. De Schutter</p><pre><code class="language-julia-repl">julia&gt; T = randn(3,3);

julia&gt; sys1 = ssrand(1,1,3);

julia&gt; sys2 = ControlSystems.similarity_transform(sys1, T);


julia&gt; T2 = find_similarity_transform(sys1, sys2);

julia&gt; T2 ≈ T
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace2.jl#L618-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.getARXregressor-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Any, Any}" href="#ControlSystemIdentification.getARXregressor-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Any, Any}"><code>ControlSystemIdentification.getARXregressor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getARXregressor(y::AbstractVector,u::AbstractVecOrMat, na, nb; inputdelay = ones(Int, size(nb)))</code></pre><p>Returns a shortened output signal <code>y</code> and a regressor matrix <code>A</code> such that the least-squares ARX model estimate of order <code>na,nb</code> is <code>y\A</code> Return a regressor matrix used to fit an ARX model on, e.g., the form <code>A(z)y = B(z)f(u)</code> with output <code>y</code> and input <code>u</code> where the order of autoregression is <code>na</code>, the order of input moving average is <code>nb</code> and an optional input delay <code>inputdelay</code>. Caution, changing the input delay changes the order to <code>nb + inputdelay - 1</code>. An <code>inputdelay = 0</code> results in a direct term. </p><p><strong>Example</strong></p><p>Here we test the model with the Function <code>f(u) = √(|u|)</code></p><pre><code class="language-julia">A     = [1,2*0.7*1,1] # A(z) coeffs
B     = [10,5] # B(z) coeffs
u     = randn(100) # Simulate 100 time steps with Gaussian input
y     = filt(B,A,u)
yr,A  = getARXregressor(y,u,3,2) # We assume that we know the system order 3,2
x     = A\yr # Estimate model polynomials
plot([yr A*x], lab=[&quot;Signal&quot; &quot;Prediction&quot;])</code></pre><p>For nonlinear ARX-models, see <a href="https://github.com/baggepinnen/BasisFunctionExpansions.jl/">BasisFunctionExpansions.jl</a>. See also <code>arx</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.getARregressor-Tuple{AbstractVector{T} where T, Any}" href="#ControlSystemIdentification.getARregressor-Tuple{AbstractVector{T} where T, Any}"><code>ControlSystemIdentification.getARregressor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yt,A = getARregressor(y::AbstractVector, na)</code></pre><p>Returns values such that <code>x = A\yt</code>. See <a href="#ControlSystemIdentification.getARXregressor"><code>getARXregressor</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.iddata" href="#ControlSystemIdentification.iddata"><code>ControlSystemIdentification.iddata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iddata(y,       Ts = nothing)
iddata(y, u,    Ts = nothing)
iddata(y, u, x, Ts = nothing)</code></pre><p>Returns the appropriate identification-data object, depending on the input.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractArray</code>: output data (required)</li><li><code>u::AbstractArray</code>: input data (if available)</li><li><code>x::AbstractArray</code>: state data (if available)</li><li><code>Ts::Union{Real,Nothing} = nothing</code>: optional sample time</li></ul><p>If the time-series are multivariate, time is in the <em>last</em> dimension.</p><p><strong>Operations on iddata</strong></p><ul><li><a href="#ControlSystemIdentification.prefilter-Tuple{Any, ControlSystemIdentification.InputOutputData}"><code>prefilter</code></a></li><li><a href="@ref"><code>resample</code></a></li><li>append two along the time dimension <code>[d1 d2]</code></li><li>index time series <code>d[output_index, input_index]</code></li><li>index the time axis with indices <code>d[time_indices]</code></li><li>index the time axis with seconds <code>d[3Sec:12Sec]</code> (<code>using ControlSystemIdentification: Sec</code>)</li><li>access number of inputs, outputs and sample time: <code>d.nu, d.ny, d.Ts</code></li><li>access the time time vector <code>d.t</code></li><li>premultiply to scale outputs <code>C * d</code></li><li>postmultiply to scale inputs <code>d * B</code></li><li><a href="#DelimitedFiles.writedlm"><code>writedlm</code></a></li><li><a href="#ControlSystemIdentification.ramp_in-Tuple{ControlSystemIdentification.InputOutputData, Int64}"><code>ramp_in</code></a>, <a href="@ref"><code>ramp_out</code></a></li><li><code>plot</code></li><li><a href="#ControlSystemIdentification.specplot"><code>specplot</code></a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iddata(randn(10))
Output data of length 10 with 1 outputs

julia&gt; iddata(randn(10), randn(10), 1)
InputOutput data of length 10 with 1 outputs and 1 inputs

julia&gt; d = iddata(randn(2, 10), randn(3, 10), 0.1)
InputOutput data of length 10 with 2 outputs and 3 inputs

julia&gt; [d d] # Concatenate along time
InputOutput data of length 20 with 2 outputs and 3 inputs

julia&gt; d[1:3]
InputOutput data of length 3 with 2 outputs and 3 inputs

julia&gt; d.nu
3

julia&gt; d.t # access time vector
0.0:0.1:0.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L79-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector{T} where T}" href="#ControlSystemIdentification.iddata-Tuple{AbstractArray, AbstractArray, AbstractVector{T} where T}"><code>ControlSystemIdentification.iddata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iddata(y::AbstractArray, u::AbstractArray, w::AbstractVector)</code></pre><p>Create a frequency-domain input-output data object. <code>w</code> is expected to be in rad/s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}" href="#ControlSystemIdentification.impulseest-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>ControlSystemIdentification.impulseest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ir, t, Σ = impulseest(d::AbstractIdData, n; λ=0, estimator=ls)</code></pre><p>Estimates the system impulse response by fitting an <code>n</code>:th order FIR model. Returns impulse-response estimate, time vector and covariance matrix. See also <code>impulseestplot</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frd.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.impulseestplot" href="#ControlSystemIdentification.impulseestplot"><code>ControlSystemIdentification.impulseestplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">impulseestplot(data,n)</code></pre><p>Estimates the system impulse response by fitting an <code>n</code>:th order FIR model and plots the result with a 95% confidence band. See also <code>impulseestplot</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L244-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.kautz-Tuple{AbstractVector{T} where T, Any}" href="#ControlSystemIdentification.kautz-Tuple{AbstractVector{T} where T, Any}"><code>ControlSystemIdentification.kautz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kautz(a::Vector, h)</code></pre><p>Construct a discrete-time Kautz basis of length with poles at <code>a</code> amd sample time <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/basis_functions.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.laguerre-Tuple{Any, Any}" href="#ControlSystemIdentification.laguerre-Tuple{Any, Any}"><code>ControlSystemIdentification.laguerre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laguerre(a::Number, Nq)</code></pre><p>Construct a Laguerre basis of length <code>Nq</code> with poles at <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/basis_functions.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}" href="#ControlSystemIdentification.laguerre_oo-Tuple{Number, Any}"><code>ControlSystemIdentification.laguerre_oo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laguerre_oo(a::Number, Nq)</code></pre><p>Construct an output orthogonalized Laguerre basis of length <code>Nq</code> with poles at <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/basis_functions.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous, S} where S&lt;:(ControlSystems.SisoTf{T} where T)}" href="#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous, S} where S&lt;:(ControlSystems.SisoTf{T} where T)}"><code>ControlSystemIdentification.minimum_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_phase(G)</code></pre><p>Move zeros and poles of <code>G</code> from the unstable half plane to the stable. If <code>G</code> is a statespace system, it&#39;s converted to a transfer function first. This can incur loss of precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/basis_functions.jl#L231-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any, N} where N}" href="#ControlSystemIdentification.model_spectrum-Tuple{Any, Any, Vararg{Any, N} where N}"><code>ControlSystemIdentification.model_spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model_spectrum(f, h, args...; kwargs...)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>f</code>: the model-estimation function, e.g., <code>ar,arma</code></li><li><code>h</code>: The sample time</li><li><code>args</code>: arguments to <code>f</code></li><li><code>kwargs</code>: keyword arguments to <code>f</code></li></ul><p><strong>Example:</strong></p><pre><code class="language-none">using ControlSystemIdentification, DSP
T = 1000
s = sin.((1:T) .* 2pi/10)
S1 = spectrogram(s,window=hanning)
estimator = model_spectrum(ar,1,2)
S2 = spectrogram(s,estimator,window=rect)
plot(plot(S1),plot(S2)) # Requires the package LPVSpectral.jl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/spectrogram.jl#L93-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.n4sid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}" href="#ControlSystemIdentification.n4sid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.n4sid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">res = n4sid(data, r=:auto; verbose=false)</code></pre><p>Estimate a statespace model using the n4sid method. Returns an object of type <a href="#ControlSystemIdentification.N4SIDStateSpace"><code>N4SIDStateSpace</code></a> where the model is accessed as <code>res.sys</code>.</p><p>Implements the simplified algorithm (alg 2) from &quot;N4SID: Subspace Algorithms for the Identification of Combined Deterministic Stochastic Systems&quot; PETER VAN OVERSCHEE and BART DE MOOR</p><p>The frequency weighting is borrowing ideas from &quot;Frequency Weighted Subspace Based System Identication in the Frequency Domain&quot;, Tomas McKelvey 1996. In particular, we apply the output frequency weight matrix (Fy) as it appears in eqs. (16)-(18).</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Identification data <code>data = iddata(y,u)</code></li><li><code>r</code>: Rank of the model (model order)</li><li><code>verbose</code>: Print stuff?</li><li><code>Wf</code>: A frequency-domain model of measurement disturbances. To focus the attention of the model on a narrow frequency band, try something like <code>Wf = Bandstop(lower, upper, fs=1/Ts)</code> to indicate that there are disturbances <em>outside</em> this band.</li><li><code>i</code>: Algorithm parameter, generally no need to tune this</li><li><code>γ</code>: Set this to a value between (0,1) to stabilize unstable models such that the largest eigenvalue has magnitude γ.</li><li><code>zeroD</code>: defaults to false</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}" href="#ControlSystemIdentification.noise_model-Tuple{AbstractPredictionStateSpace}"><code>ControlSystemIdentification.noise_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noise_model(sys::AbstractPredictionStateSpace)</code></pre><p>Return a model of the noise driving the system, <code>v</code>, in</p><div>\[x&#39; = Ax + Bu + Kv
y = Cx + Du + v\]</div><p>The model neglects u and is given by</p><div>\[x&#39; = Ax + Kv
y = Cx + v\]</div><p>Also called the &quot;innovation form&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.okid" href="#ControlSystemIdentification.okid"><code>ControlSystemIdentification.okid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">H = okid(d::AbstractIdData, nx, l = 5nx; p = 1, λ=0, estimator = /)</code></pre><p>Observer Kalman filter identification. Returns the Markov parameters <code>H</code> size <code>n_out×n_in×l+1</code></p><p><strong>Arguments:</strong></p><ul><li><code>nx</code>: Model order</li><li><code>l</code>: Number of Markov parameters to estimate.</li><li><code>λ</code>: Regularization parameter</li><li><code>p</code>: Optionally, delete the first <code>p</code> columns in the internal Hankel matrices to account for initial conditions != 0. If <code>x0 != 0</code>, try setting <code>p</code> around the same value as <code>l</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace.jl#L374-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.pem-Tuple{Any}" href="#ControlSystemIdentification.pem-Tuple{Any}"><code>ControlSystemIdentification.pem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sys, x0, opt = pem(data; nx, kwargs...)</code></pre><p>System identification using the prediction-error method.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: iddata object containing <code>y</code> and <code>u</code>.<ul><li><code>y</code>: Measurements, either a matrix with time along dim 2, or a vector of vectors</li><li><code>u</code>: Control signals, same structure as <code>y</code></li></ul></li><li><code>nx</code>: Number of poles in the estimated system. Thus number should be chosen as number of system poles plus number of poles in noise models for measurement noise and load disturbances.</li><li><code>focus</code>: Either <code>:prediction</code> or <code>:simulation</code>. If <code>:simulation</code> is chosen, a two stage problem is solved with prediction focus first, followed by a refinement for simulation focus.</li><li><code>metric</code>: A Function determining how the size of the residuals is measured, default <code>sse</code> (e&#39;e), but any Function such as <code>norm</code>, <code>e-&gt;sum(abs,e)</code> or <code>e -&gt; e&#39;Q*e</code> could be used.</li><li><code>regularizer(p)=0</code>: function for regularization. The structure of <code>p</code> is detailed below</li><li><code>solver</code> Defaults to <code>Optim.BFGS()</code></li><li><code>stabilize_predictor=true</code>: Modifies the estimated Kalman gain <code>K</code> in case <code>A-KC</code> is not stable by moving all unstable eigenvalues to the unit circle.</li><li><code>difficult=false</code>: If the identification problem appears to be difficult and ends up in a local minimum, set this flag to true to solve an initial global optimization problem to supply a good initial guess. This is expected to take some time.</li><li><code>kwargs</code>: additional keyword arguments are sent to <code>Optim.Options</code>.</li></ul><p><strong>Return values</strong></p><ul><li><code>sys::StateSpaceNoise</code>: identified system. Can be converted to <code>StateSpace</code> by <code>convert(StateSpace, sys)</code> or <code>ss(sys)</code>, but this will discard the Kalman gain matrix, see <code>innovation_form</code> to obtain a predictor system.</li><li><code>x0</code>: Estimated initial state</li><li><code>opt</code>: Optimization problem structure. Contains info of the result of the optimization problem</li></ul><p><strong>Structure of parameter vector <code>p</code></strong></p><p>The parameter vector is of type <a href="https://github.com/jonniedie/ComponentArrays.jl"><code>ComponentVector</code></a> and the fields <code>A,B,K,x0</code> can be accessed as <code>p.A</code> etc. The internal storage is according to</p><pre><code class="language-julia">A = size(nx,nx)
B = size(nx,nu)
K = size(nx,ny)
x0 = size(nx)
p = [A[:]; B[:]; K[:]; x0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/pem.jl#L23-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}" href="#ControlSystemIdentification.plr-Tuple{ControlSystemIdentification.AbstractIdData, Any, Any, Any}"><code>ControlSystemIdentification.plr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">G, Gn = plr(d::AbstractIdData,na,nb,nc; initial_order = 20)</code></pre><p>Perform pseudo-linear regression to estimate a model on the form <code>Ay = Bu + Cw</code> The residual sequence is estimated by first estimating a high-order arx model, whereafter the estimated residual sequence is included in a second estimation problem. The return values are the estimated system model, and the estimated noise model. <code>G</code> and <code>Gn</code> will always have the same denominator polynomial.</p><p><code>armax</code> is an alias for <code>plr</code>. See also <a href="../ss/#ControlSystemIdentification.pem"><code>pem</code></a>, <a href="#ControlSystemIdentification.ar"><code>ar</code></a>, <a href="#ControlSystemIdentification.arx"><code>arx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L502-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.predplot" href="#ControlSystemIdentification.predplot"><code>ControlSystemIdentification.predplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predplot(sys, data, x0=nothing; ploty=true, plote=false)</code></pre><p>Plot system simulation and measured output to compare them. <code>ploty</code> determines whether or not to plot the measured signal <code>plote</code> determines whether or not to plot the residual</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prefilter-Tuple{Any, ControlSystemIdentification.InputOutputData}" href="#ControlSystemIdentification.prefilter-Tuple{Any, ControlSystemIdentification.InputOutputData}"><code>ControlSystemIdentification.prefilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prefilter(f, d::InputOutputData)</code></pre><p>Apply filter coefficients to identification data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frequency_weights.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}" href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, DSP.Filters.FilterType}"><code>ControlSystemIdentification.prefilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prefilter(d::AbstractIdData, responsetype::FilterType)</code></pre><p>Filter both input and output of the identification data using zero-phase filtering (<code>filtfilt</code>). Since both input and output is filtered, linear identification will not be affected in any other way than to focus the fit on the selected frequency range, i.e. the range that has high gain in the provided filter. Note, if the system that generated <code>d</code> is nonlinear, identification might be severely impacted by this transformation. Verify linearity with, e.g., <code>coherenceplot</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frequency_weights.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}" href="#ControlSystemIdentification.prefilter-Tuple{ControlSystemIdentification.AbstractIdData, Number, Number}"><code>ControlSystemIdentification.prefilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prefilter(d::AbstractIdData, l::Number, u::Number)</code></pre><p>Filter input and output with a bandpass filter between <code>l</code> and <code>u</code> Hz. If <code>l = 0</code> a lowpass filter will be used, and if <code>u = Inf</code> a highpass filter will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frequency_weights.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.ramp_in-Tuple{ControlSystemIdentification.InputOutputData, Int64}" href="#ControlSystemIdentification.ramp_in-Tuple{ControlSystemIdentification.InputOutputData, Int64}"><code>ControlSystemIdentification.ramp_in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ramp_in(d::InputOutputData, h::Int; rev = false)</code></pre><p>Multiply the initial <code>h</code> samples of input and output signals with a linearly increasing ramp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L321-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.simplot" href="#ControlSystemIdentification.simplot"><code>ControlSystemIdentification.simplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplot(sys, data, x0=nothing; ploty=true, plote=false)</code></pre><p>Plot system simulation and measured output to compare them. <code>ploty</code> determines whether or not to plot the measured signal <code>plote</code> determines whether or not to plot the residual</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.simulate" href="#ControlSystemIdentification.simulate"><code>ControlSystemIdentification.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulate(sys, u, x0 = nothing)
simulate(sys, d, x0 = nothing)</code></pre><p>See also <a href="#ControlSystemIdentification.simplot"><code>simplot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.specplot" href="#ControlSystemIdentification.specplot"><code>ControlSystemIdentification.specplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">specplot(d::IdData)</code></pre><p>Plot a spectrogram of the input and output timeseries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/plotting.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any, N} where N}" href="#ControlSystemIdentification.subspaceid-Tuple{FRD, Real, Vararg{Any, N} where N}"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subspaceid(frd::FRD, args...; estimate_x0 = false, kwargs...)</code></pre><p>If a frequency-reponse data object is supplied</p><ul><li>The FRD will be automatically converted to an <a href="@ref"><code>InputOutputFreqData</code></a></li><li><code>estimate_x0</code> is by default set to 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace2.jl#L372-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}" href="#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputData, Any}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subspaceid(
    data::InputOutputData,
    nx = :auto;
    verbose = false,
    r = nx === :auto ? min(length(data) ÷ 20, 20) : nx + 10, # the maximal prediction horizon used
    s1 = r, # number of past outputs
    s2 = r, # number of past inputs
    W = :MOESP,
    zeroD = false,
    stable = true, 
    focus = :prediction,
    svd::F1 = svd!,
    scaleU = true,
    Aestimator::F2 = \,
    Bestimator::F3 = \,
    weights = nothing,
)</code></pre><p>Estimate a state-space model using subspace-based identification.</p><p>Ref: Ljung, Theory for the user.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Identification data <a href="../iddata/#ControlSystemIdentification.iddata"><code>iddata</code></a></li><li><code>nx</code>: Rank of the model (model order)</li><li><code>verbose</code>: Print stuff?</li><li><code>r</code>: Prediction horizon. The model may perform better on simulation if this is made longer, at the expense of more computation time.</li><li><code>s1</code>: past horizon of outputs</li><li><code>s2</code>: past horizon of inputs</li><li><code>W</code>: Weight type, choose between <code>:MOESP, :CVA, :N4SID, :IVM</code></li><li><code>zeroD</code>: Force the <code>D</code> matrix to be zero.</li><li><code>stable</code>: Stabilize unstable system using eigenvalue reflection.</li><li><code>focus</code>: <code>:prediction</code> or <code>simulation</code></li><li><code>svd</code>: The function to use for <code>svd</code></li><li><code>scaleU</code>: Rescale the input channels to have the same energy.</li><li><code>Aestimator</code>: Estimator function used to estimate <code>A,C</code>.</li><li><code>Bestimator</code>: Estimator function used to estimate <code>B,D</code>.</li><li><code>weights</code>: A vector of weights can be provided if the <code>Bestimator</code> is <code>wls</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace2.jl#L158-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}" href="#ControlSystemIdentification.subspaceid-Union{Tuple{ControlSystemIdentification.InputOutputFreqData}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real}, Tuple{ControlSystemIdentification.InputOutputFreqData, Real, Union{Int64, Symbol}}} where {F1, F2, F3}"><code>ControlSystemIdentification.subspaceid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subspaceid(data::InputOutputFreqData,
    Ts = data.Ts,
    nx = :auto;
    cont = false,
    verbose = false,
    r = nx === :auto ? min(length(data) ÷ 20, 20) : 2nx, # Internal model order
    zeroD = false,
    estimate_x0 = true,
    stable = true, 
    svd = svd!,
    Aestimator = \,
    Bestimator = \,
    weights = nothing
)</code></pre><p>Estimate a state-space model using subspace-based identification in the frequency domain.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: A frequency-domain identification data object.</li><li><code>Ts</code>: Sample time at which the data was collected</li><li><code>nx</code>: Desired model order, an interer or <code>:auto</code>.</li><li><code>cont</code>: Return a continuous-time model? A bilinear transformation is used to convert the estimated discrete-time model, see function <code>d2c</code>.</li><li><code>verbose</code>: Print stuff?</li><li><code>r</code>: Internal model order, must be ≥ <code>nx</code>.</li><li><code>zeroD</code>: Force the <code>D</code> matrix to be zero.</li><li><code>estimate_x0</code>: Esimation of extra parameters to account for initial conditions. This may be required if the data comes from the fft of time-domain data, but may not be required if the data is collected using frequency-response analysis with exactly periodic input and proper handling of transients.</li><li><code>stable</code>: For the model to be stable (uses <a href="@ref"><code>schur_stab</code></a>).</li><li><code>svd</code>: The <code>svd</code> function to use.</li><li><code>Aestimator</code>: The estimator of the <code>A</code> matrix (and initial <code>C</code>-matrix).</li><li><code>Bestimator</code>: The estimator of B/D and C/D matrices.</li><li><code>weights</code>: An optional vector of frequency weights of the same length as the number of frequencies in `data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/subspace2.jl#L388-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.tfest" href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tfest(
    data::FRD,
    p0,
    link = log ∘ abs;
    freq_weight = sqrt(data.w[1]*data.w[end]),
    refine = true,
    opt = BFGS(),
    opts = Optim.Options(
        store_trace       = true,
        show_trace        = true,
        show_every        = 1,
        iterations        = 100,
        allow_f_increases = false,
        time_limit        = 100,
        x_tol             = 0,
        f_tol             = 0,
        g_tol             = 1e-8,
        f_calls_limit     = 0,
        g_calls_limit     = 0,
    ),
)</code></pre><p>Fit a parametric transfer function to frequency-domain data.</p><p>The initial pahse of the optimization solves</p><div>\[\operatorname{minimize}_{B,A}{|| B/l - A||}\]</div><p>and the second stage (if refine=true) solves </p><div>\[\operatorname{minimize}_{B,A}{|| \text{link}\left(\dfrac{B}{A}\right) - \text{link}\left(l\right)||}\]</div><p>(<code>abs2(link(B/A) - link(l))</code>)</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: An <code>FRD</code> onbject with frequency domain data.</li><li><code>p0</code>: Initial parameter guess. Can be a <code>NamedTuple</code> or <code>ComponentVector</code> with fields <code>b,a</code> specifying numerator and denominator as they appear in the call to <code>tf</code>, i.e., <code>(b = [1.0], a = [1.0,1.0,1.0])</code>. Can also be an instace of <code>TransferFunction</code>.</li><li><code>link</code>: By default, phase information is discarded in the fitting. To include phase, change to <code>link = log</code>.</li><li><code>freq_weight</code>: Apply weighting with the inverse frequency. The value determines the cutoff frequency before which the weight is constant, after which the weight decreases linearly. Defaults to the geometric mean of the smallest and largest frequency.</li><li><code>refine</code>: Indicate whether or not a second optimization stage is performed to refine the results of the first.</li><li><code>opt</code>: The Optim optimizer to use.</li><li><code>opts</code>: <code>Optim.Options</code> controlling the solver options.</li></ul><p>See also <a href="#ControlSystemIdentification.minimum_phase-Tuple{TransferFunction{Continuous, S} where S&lt;:(ControlSystems.SisoTf{T} where T)}"><code>minimum_phase</code></a> to transform a possibly non-minimum phase system to minimum phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L595-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.tfest" href="#ControlSystemIdentification.tfest"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">H, N = tfest(data, σ = 0.05)</code></pre><p>Estimate a transfer function model using the Correlogram approach.     Both <code>H</code> and <code>N</code> are of type <code>FRD</code> (frequency-response data).</p><p><code>σ</code> determines the width of the Gaussian window applied to the estimated correlation functions before FFT. A larger <code>σ</code> implies less smoothing.</p><ul><li><code>H</code> = Syu/Suu             Process transfer function</li><li><code>N</code> = Sy - |Syu|²/Suu     Noise PSD</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/frd.jl#L124-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M" href="#ControlSystemIdentification.tfest-Union{Tuple{M}, Tuple{FRD, AbstractStateSpace}} where M"><code>ControlSystemIdentification.tfest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tfest(data::FRD, basis::AbstractStateSpace; 
    freq_weight = 1 ./ (data.w .+ data.w[2]),
    opt = BFGS(),
    metric::M = abs2,
    opts = Optim.Options(
        store_trace       = true,
        show_trace        = true,
        show_every        = 50,
        iterations        = 1000000,
        allow_f_increases = false,
        time_limit        = 100,
        x_tol             = 1e-5,
        f_tol             = 0,
        g_tol             = 1e-8,
        f_calls_limit     = 0,
        g_calls_limit     = 0,
)</code></pre><p>Fit a parametric transfer function to frequency-domain data using a pre-specified basis.</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>: An <code>FRD</code> onbject with frequency domain data.</li></ul><p>function kautz(a::AbstractVector)</p><ul><li><code>basis</code>: A basis for the estimation. See, e.g., <code>laguerre, laguerre_oo, kautz</code></li><li><code>freq_weight</code>: A vector of weights per frequency. The default is approximately <code>1/f</code>. </li><li><code>opt</code>: The Optim optimizer to use.</li><li><code>opts</code>: <code>Optim.Options</code> controlling the solver options.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L709-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemIdentification.wtls_estimator" href="#ControlSystemIdentification.wtls_estimator"><code>ControlSystemIdentification.wtls_estimator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wtls_estimator(y,na,nb, σu=0)</code></pre><p>Create an estimator function for estimation of arx models in the presence of measurement noise. If the noise variance on the input <code>σu</code> (model errors) is known, this can be specified for increased accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L860-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample-Tuple{AbstractStateSpace{var&quot;#s254&quot;} where var&quot;#s254&quot;&lt;:Discrete, AbstractMatrix{T} where T, Real}" href="#DSP.Filters.resample-Tuple{AbstractStateSpace{var&quot;#s254&quot;} where var&quot;#s254&quot;&lt;:Discrete, AbstractMatrix{T} where T, Real}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DSP.resample(sys::AbstractStateSpace{&lt;:Discrete}, Qd::AbstractMatrix, newh::Real)</code></pre><p>Change sample time of covariance matrix <code>Qd</code> beloning to <code>sys</code> to <code>newh</code>. This function does not handle the measurement covariance, how to do this depends on context. If the faster sampled signal has the same measurement noise, no change should be made. If the slower sampled signal was downsampled with filtering, the measurement covariance should be increased if the system is changed to a faster sample rate. To maintain the frequency response of the system, the measurement covariance should be modified accordinly.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A discrete-time system that has dynamics noise covariance matric <code>Qd</code>.</li><li><code>Qd</code>: Covariance matrix of dynamics noise.</li><li><code>newh</code>: The new sample time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L385-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample-Tuple{AbstractStateSpace{var&quot;#s254&quot;} where var&quot;#s254&quot;&lt;:Discrete, Real}" href="#DSP.Filters.resample-Tuple{AbstractStateSpace{var&quot;#s254&quot;} where var&quot;#s254&quot;&lt;:Discrete, Real}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resample(sys::AbstractStateSpace{&lt;:Discrete}, newh::Real)</code></pre><p>Change sample-time of sys to <code>newh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}" href="#DSP.Filters.resample-Tuple{ControlSystemIdentification.AbstractIdData, Any}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dr = resample(d::InputOutputData, f)</code></pre><p>Resample iddata <code>d</code> with fraction <code>f</code>, e.g., <code>f = fs_new / fs_original</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}" href="#StatsAPI.predict-Tuple{Any, ControlSystemIdentification.AbstractIdData, Vararg{Any, N} where N}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">predict(sys, d::AbstractIdData, args...)
predict(sys, y, u, x0 = nothing)</code></pre><p>See also <a href="#ControlSystemIdentification.predplot"><code>predplot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{TransferFunction, Any}" href="#StatsAPI.predict-Tuple{TransferFunction, Any}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yh = predict(ar::TransferFunction, y)</code></pre><p>Predict AR model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/ControlSystemIdentification.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}" href="#StatsAPI.predict-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">predict(ARX::TransferFunction, d::InputOutputData)</code></pre><p>One step ahead prediction for an ARX process.  The length of the returned prediction is <code>length(d) - max(na, nb)</code></p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; predict(tf(1, [1, -1], 1), iddata(1:10, 1:10))
9-element Vector{Int64}:
  2
  4
  6
  8
 10
 12
 14
 16
 18</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L156-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.residuals-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}" href="#StatsAPI.residuals-Tuple{TransferFunction, ControlSystemIdentification.InputOutputData}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">residuals(ARX::TransferFunction, d::InputOutputData)</code></pre><p>Calculates the residuals <code>v = Ay - Bu</code> of an ARX process and InputOutputData d. The length of the returned residuals is <code>length(d) - max(na, nb)</code></p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; ARX = tf(1, [1, -1], 1)
TransferFunction{Discrete{Int64}, ControlSystems.SisoRational{Int64}}
  1
-----
z - 1

Sample Time: 1 (seconds)
Discrete-time transfer function model

julia&gt; u = 1:5
1:5

julia&gt; y = lsim(ARX, u, 1:5)[1][:]
5-element Vector{Float64}:
  0.0
  1.0
  3.0
  6.0
 10.0

julia&gt; d = iddata(y, u)
InputOutput data of length 5 with 1 outputs and 1 inputs

julia&gt; residuals(ARX, d)
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/arx.jl#L106-L142">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ControlSystems.StateSpace</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="DelimitedFiles.writedlm" href="#DelimitedFiles.writedlm"><code>DelimitedFiles.writedlm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DelimitedFiles.writedlm(io::IO, d::AbstractIdData, args...; kwargs...)</code></pre><p>Write identification data to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/ControlSystemIdentification.jl/blob/34208a42aee266cc571d2b3b42f3192f264e778e/src/types.jl#L312-L316">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LowLevelParticleFilters.KalmanFilter</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/temp/">« Temperature control</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 February 2022 08:01">Tuesday 15 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
